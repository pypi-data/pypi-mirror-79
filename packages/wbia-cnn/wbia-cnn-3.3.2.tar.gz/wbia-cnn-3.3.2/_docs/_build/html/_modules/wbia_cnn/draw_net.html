
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>wbia_cnn.draw_net &#8212; wbia-cnn 3.3.0 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for wbia_cnn.draw_net</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions to create network diagrams from a list of Layers.</span>

<span class="sd">References:</span>
<span class="sd">    # Adapted from</span>
<span class="sd">    https://github.com/ebenolson/Lasagne/blob/master/examples/draw_net.py</span>

<span class="sd">    # TODO:</span>
<span class="sd">    https://github.com/dnouri/nolearn/blob/master/nolearn/lasagne/visualize.py</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">join</span><span class="p">,</span> <span class="n">exists</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>
<span class="kn">from</span> <span class="nn">wbia_cnn</span> <span class="kn">import</span> <span class="n">utils</span>

<span class="nb">print</span><span class="p">,</span> <span class="n">rrr</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">inject2</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="imwrite_theano_symbolic_graph"><a class="viewcode-back" href="../../wbia_cnn.html#wbia_cnn.draw_net.imwrite_theano_symbolic_graph">[docs]</a><span class="k">def</span> <span class="nf">imwrite_theano_symbolic_graph</span><span class="p">(</span><span class="n">thean_expr</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">theano</span>

    <span class="n">graph_dpath</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span>
    <span class="n">graph_fname</span> <span class="o">=</span> <span class="s1">&#39;symbolic_graph.png&#39;</span>
    <span class="n">graph_fpath</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">unixjoin</span><span class="p">(</span><span class="n">graph_dpath</span><span class="p">,</span> <span class="n">graph_fname</span><span class="p">)</span>
    <span class="n">ut</span><span class="o">.</span><span class="n">ensuredir</span><span class="p">(</span><span class="n">graph_dpath</span><span class="p">)</span>
    <span class="n">theano</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">pydotprint</span><span class="p">(</span><span class="n">thean_expr</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="n">graph_fpath</span><span class="p">,</span> <span class="n">var_with_name_simple</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ut</span><span class="o">.</span><span class="n">startfile</span><span class="p">(</span><span class="n">graph_fpath</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">graph_fpath</span></div>


<div class="viewcode-block" id="draw_neural_net"><a class="viewcode-back" href="../../wbia_cnn.html#wbia_cnn.draw_net.draw_neural_net">[docs]</a><span class="k">def</span> <span class="nf">draw_neural_net</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">layer_sizes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    References:</span>
<span class="sd">        # Taken from</span>
<span class="sd">        https://gist.github.com/craffel/2d727968c3aaebd10359</span>

<span class="sd">    Draw a neural network cartoon using matplotilb.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; fig = plt.figure(figsize=(12, 12))</span>
<span class="sd">        &gt;&gt;&gt; draw_neural_net(fig.gca(), .1, .9, .1, .9, [4, 7, 2])</span>

<span class="sd">    :parameters:</span>
<span class="sd">        - ax : matplotlib.axes.AxesSubplot</span>
<span class="sd">            The axes on which to plot the cartoon (get e.g. by plt.gca())</span>
<span class="sd">        - left : float</span>
<span class="sd">            The center of the leftmost node(s) will be placed here</span>
<span class="sd">        - right : float</span>
<span class="sd">            The center of the rightmost node(s) will be placed here</span>
<span class="sd">        - bottom : float</span>
<span class="sd">            The center of the bottommost node(s) will be placed here</span>
<span class="sd">        - top : float</span>
<span class="sd">            The center of the topmost node(s) will be placed here</span>
<span class="sd">        - layer_sizes : list of int</span>
<span class="sd">            List of layer sizes, including input and output dimensionality</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

    <span class="c1"># n_layers = len(layer_sizes)</span>
    <span class="n">v_spacing</span> <span class="o">=</span> <span class="p">(</span><span class="n">top</span> <span class="o">-</span> <span class="n">bottom</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">layer_sizes</span><span class="p">))</span>
    <span class="n">h_spacing</span> <span class="o">=</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layer_sizes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Nodes</span>
    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">layer_size</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer_sizes</span><span class="p">):</span>
        <span class="n">layer_top</span> <span class="o">=</span> <span class="n">v_spacing</span> <span class="o">*</span> <span class="p">(</span><span class="n">layer_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">top</span> <span class="o">+</span> <span class="n">bottom</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">layer_size</span><span class="p">):</span>
            <span class="n">circle</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">(</span>
                <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">h_spacing</span> <span class="o">+</span> <span class="n">left</span><span class="p">,</span> <span class="n">layer_top</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="n">v_spacing</span><span class="p">),</span>
                <span class="n">v_spacing</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span>
                <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
                <span class="n">zorder</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span>
    <span class="c1"># Edges</span>
    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">layer_size_a</span><span class="p">,</span> <span class="n">layer_size_b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">layer_sizes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">layer_sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="p">):</span>
        <span class="n">layer_top_a</span> <span class="o">=</span> <span class="n">v_spacing</span> <span class="o">*</span> <span class="p">(</span><span class="n">layer_size_a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">top</span> <span class="o">+</span> <span class="n">bottom</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">layer_top_b</span> <span class="o">=</span> <span class="n">v_spacing</span> <span class="o">*</span> <span class="p">(</span><span class="n">layer_size_b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">top</span> <span class="o">+</span> <span class="n">bottom</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">layer_size_a</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">layer_size_b</span><span class="p">):</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="n">h_spacing</span> <span class="o">+</span> <span class="n">left</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">h_spacing</span> <span class="o">+</span> <span class="n">left</span><span class="p">],</span>
                    <span class="p">[</span><span class="n">layer_top_a</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="n">v_spacing</span><span class="p">,</span> <span class="n">layer_top_b</span> <span class="o">-</span> <span class="n">o</span> <span class="o">*</span> <span class="n">v_spacing</span><span class="p">],</span>
                    <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">line</span><span class="p">)</span></div>


<div class="viewcode-block" id="show_arch_nx_graph"><a class="viewcode-back" href="../../wbia_cnn.html#wbia_cnn.draw_net.show_arch_nx_graph">[docs]</a><span class="k">def</span> <span class="nf">show_arch_nx_graph</span><span class="p">(</span><span class="n">layers</span><span class="p">,</span> <span class="n">fnum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fullinfo</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m wbia_cnn.draw_net show_arch_nx_graph:0 --show</span>
<span class="sd">        python -m wbia_cnn.draw_net show_arch_nx_graph:1 --show</span>

<span class="sd">    Example0:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from wbia_cnn.draw_net import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; from wbia_cnn import models</span>
<span class="sd">        &gt;&gt;&gt; model = models.mnist.MNISTModel(batch_size=128, output_dims=10,</span>
<span class="sd">        &gt;&gt;&gt;                                 data_shape=(24, 24, 3))</span>
<span class="sd">        &gt;&gt;&gt; model.init_arch()</span>
<span class="sd">        &gt;&gt;&gt; layers = model.get_all_layers()</span>
<span class="sd">        &gt;&gt;&gt; show_arch_nx_graph(layers)</span>
<span class="sd">        &gt;&gt;&gt; ut.quit_if_noshow()</span>
<span class="sd">        &gt;&gt;&gt; import plottool as pt</span>
<span class="sd">        &gt;&gt;&gt; ut.show_if_requested()</span>

<span class="sd">    Example1:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from wbia_cnn.draw_net import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; from wbia_cnn import models</span>
<span class="sd">        &gt;&gt;&gt; model = models.SiameseCenterSurroundModel(autoinit=True)</span>
<span class="sd">        &gt;&gt;&gt; layers = model.get_all_layers()</span>
<span class="sd">        &gt;&gt;&gt; show_arch_nx_graph(layers)</span>
<span class="sd">        &gt;&gt;&gt; ut.quit_if_noshow()</span>
<span class="sd">        &gt;&gt;&gt; import plottool as pt</span>
<span class="sd">        &gt;&gt;&gt; ut.show_if_requested()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
    <span class="kn">import</span> <span class="nn">plottool</span> <span class="k">as</span> <span class="nn">pt</span>
    <span class="kn">from</span> <span class="nn">Lasagne</span> <span class="kn">import</span> <span class="n">lasagne</span>

    <span class="c1"># from matplotlib import offsetbox</span>
    <span class="c1"># import matplotlib as mpl</span>

    <span class="n">REMOVE_BATCH_SIZE</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="kn">from</span> <span class="nn">wbia_cnn</span> <span class="kn">import</span> <span class="n">net_strs</span>

    <span class="k">def</span> <span class="nf">get_hex_color</span><span class="p">(</span><span class="n">layer_type</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;Input&#39;</span> <span class="ow">in</span> <span class="n">layer_type</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;#A2CECE&#39;</span>
        <span class="k">if</span> <span class="s1">&#39;Conv2D&#39;</span> <span class="ow">in</span> <span class="n">layer_type</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;#7C9ABB&#39;</span>
        <span class="k">if</span> <span class="s1">&#39;Dense&#39;</span> <span class="ow">in</span> <span class="n">layer_type</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;#6CCF8D&#39;</span>
        <span class="k">if</span> <span class="s1">&#39;Pool&#39;</span> <span class="ow">in</span> <span class="n">layer_type</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;#9D9DD2&#39;</span>
        <span class="k">if</span> <span class="s1">&#39;SoftMax&#39;</span> <span class="ow">in</span> <span class="n">layer_type</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;#7E9FD9&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;#</span><span class="si">{0:x}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">layer_type</span> <span class="o">+</span> <span class="s1">&#39;salt&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">24</span><span class="p">)</span>

    <span class="n">node_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">edge_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">edge_attrs</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">ddict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

    <span class="c1"># Make layer ids (ensure no duplicates)</span>
    <span class="n">layer_to_id</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">layer</span><span class="p">:</span> <span class="nb">repr</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span> <span class="k">if</span> <span class="n">layer</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">layer</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">keys_</span> <span class="o">=</span> <span class="n">layer_to_id</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">dups</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">find_duplicate_items</span><span class="p">(</span><span class="n">layer_to_id</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">dupval</span><span class="p">,</span> <span class="n">dupidxs</span> <span class="ow">in</span> <span class="n">dups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">newval_fmt</span> <span class="o">=</span> <span class="n">dupval</span> <span class="o">+</span> <span class="s1">&#39;_</span><span class="si">%d</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">ut</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">keys_</span><span class="p">,</span> <span class="n">dupidxs</span><span class="p">):</span>
            <span class="n">newid</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">get_nonconflicting_string</span><span class="p">(</span><span class="n">newval_fmt</span><span class="p">,</span> <span class="n">layer_to_id</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">layer_to_id</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">newid</span>

    <span class="k">def</span> <span class="nf">layerid</span><span class="p">(</span><span class="n">layer</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">layer_to_id</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span>

    <span class="n">main_nodes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
        <span class="n">layer_info</span> <span class="o">=</span> <span class="n">net_strs</span><span class="o">.</span><span class="n">get_layer_info</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>
        <span class="n">layer_type</span> <span class="o">=</span> <span class="n">layer_info</span><span class="p">[</span><span class="s1">&#39;classalias&#39;</span><span class="p">]</span>

        <span class="n">key</span> <span class="o">=</span> <span class="n">layerid</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>

        <span class="n">color</span> <span class="o">=</span> <span class="n">get_hex_color</span><span class="p">(</span><span class="n">layer_info</span><span class="p">[</span><span class="s1">&#39;classalias&#39;</span><span class="p">])</span>
        <span class="c1"># Make label</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">layer_info</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">layer_info</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">fullinfo</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">layer_info</span><span class="p">[</span><span class="s1">&#39;classalias&#39;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">layer_info</span><span class="p">[</span><span class="s1">&#39;layer_attrs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;shape&#39;</span> <span class="ow">and</span> <span class="n">REMOVE_BATCH_SIZE</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;output_shape&#39;</span> <span class="ow">and</span> <span class="n">REMOVE_BATCH_SIZE</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">: </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>

            <span class="n">nonlinearity</span> <span class="o">=</span> <span class="n">layer_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nonlinearity&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nonlinearity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">alias_map</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;LeakyRectify&#39;</span><span class="p">:</span> <span class="s1">&#39;LReLU&#39;</span><span class="p">,</span>
                <span class="p">}</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">layer_info</span><span class="p">[</span><span class="s1">&#39;nonlinearity&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">alias_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;nonlinearity:</span><span class="se">\n</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>

        <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

        <span class="c1"># append node</span>
        <span class="n">is_main_layer</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="c1"># is_main_layer = len(lasagne.layers.get_all_params(layer, trainable=True)) &gt; 0</span>
        <span class="k">if</span> <span class="n">layer_info</span><span class="p">[</span><span class="s1">&#39;classname&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">lasagne</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">normalization</span><span class="o">.</span><span class="n">__all__</span><span class="p">:</span>
            <span class="n">is_main_layer</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">layer_info</span><span class="p">[</span><span class="s1">&#39;classname&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">lasagne</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">__all__</span><span class="p">:</span>
            <span class="n">is_main_layer</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">layer_info</span><span class="p">[</span><span class="s1">&#39;classname&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;BatchNorm&#39;</span><span class="p">):</span>
            <span class="n">is_main_layer</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">layer_info</span><span class="p">[</span><span class="s1">&#39;classname&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;ElemwiseSum&#39;</span><span class="p">):</span>
            <span class="n">is_main_layer</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">layer_type</span> <span class="o">==</span> <span class="s1">&#39;Input&#39;</span><span class="p">:</span>
            <span class="n">is_main_layer</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="s1">&#39;_is_main_layer&#39;</span><span class="p">):</span>
            <span class="n">is_main_layer</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">_is_main_layer</span>

        <span class="c1"># if getattr(layer, &#39;name&#39;, &#39;&#39;) is not None and getattr(layer, &#39;name&#39;, &#39;&#39;) .endswith(&#39;/sum&#39;):</span>
        <span class="c1">#    is_main_layer = True</span>

        <span class="n">node_attr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
            <span class="n">fillcolor</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
            <span class="n">style</span><span class="o">=</span><span class="s1">&#39;filled&#39;</span><span class="p">,</span>
            <span class="n">is_main_layer</span><span class="o">=</span><span class="n">is_main_layer</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">node_attr</span><span class="p">[</span><span class="s1">&#39;is_main_layer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_main_layer</span>
        <span class="k">if</span> <span class="n">is_main_layer</span><span class="p">:</span>
            <span class="n">main_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">node_attr</span><span class="p">[</span><span class="s1">&#39;classalias&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer_info</span><span class="p">[</span><span class="s1">&#39;classalias&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">is_main_layer</span> <span class="ow">or</span> <span class="n">node_attr</span><span class="p">[</span><span class="s1">&#39;classalias&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Conv&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">node_attr</span><span class="p">[</span><span class="s1">&#39;out_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">layer</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">node_attr</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="s1">&#39;output_shape&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">output_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">depth</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">layer</span><span class="o">.</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">xshift</span> <span class="o">=</span> <span class="o">-</span><span class="n">width</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">/</span> <span class="p">(</span><span class="n">depth</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span> <span class="o">/</span> <span class="mi">3</span>
                    <span class="n">yshift</span> <span class="o">=</span> <span class="n">height</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">/</span> <span class="p">(</span><span class="n">depth</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="n">node_attr</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span>
                    <span class="n">node_attr</span><span class="p">[</span><span class="s1">&#39;xshift&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xshift</span>
                    <span class="n">node_attr</span><span class="p">[</span><span class="s1">&#39;yshift&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">yshift</span>
                    <span class="n">node_attr</span><span class="p">[</span><span class="s1">&#39;out_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">output_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">node_attr</span><span class="p">[</span><span class="s1">&#39;out_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">layer</span><span class="o">.</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">node_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_attr</span>

        <span class="n">_input_layers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="s1">&#39;input_layers&#39;</span><span class="p">):</span>
            <span class="n">_input_layers</span> <span class="o">+=</span> <span class="n">layer</span><span class="o">.</span><span class="n">input_layers</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="s1">&#39;input_layer&#39;</span><span class="p">):</span>
            <span class="n">_input_layers</span> <span class="o">+=</span> <span class="p">[</span><span class="n">layer</span><span class="o">.</span><span class="n">input_layer</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">input_layer</span> <span class="ow">in</span> <span class="n">_input_layers</span><span class="p">:</span>
            <span class="n">parent_key</span> <span class="o">=</span> <span class="n">layerid</span><span class="p">(</span><span class="n">input_layer</span><span class="p">)</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="p">(</span><span class="n">parent_key</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="n">edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

    <span class="n">main_size_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span> <span class="o">*</span> <span class="mi">4</span>
    <span class="n">sub_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">75</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span> <span class="o">*</span> <span class="mi">4</span>

    <span class="c1"># Setup scaled width and heights</span>
    <span class="n">out_size_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;out_size&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">node_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="s1">&#39;out_size&#39;</span> <span class="ow">in</span> <span class="n">v</span><span class="p">]</span>
    <span class="n">out_size_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out_size_list</span><span class="p">)</span>
    <span class="c1"># out_size_list = out_size_list[out_size_list.T[0] &gt; 1]</span>
    <span class="n">area_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">out_size_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">main_outsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out_size_list</span><span class="p">[</span><span class="n">area_arr</span><span class="o">.</span><span class="n">argmax</span><span class="p">()])</span>
    <span class="c1"># main_outsize = np.array(out_size_list[area_arr.argmin()])</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">main_size_</span> <span class="o">/</span> <span class="n">main_outsize</span>

    <span class="n">scale_dense_max</span> <span class="o">=</span> <span class="mf">0.25</span>
    <span class="n">scale_dense_min</span> <span class="o">=</span> <span class="mi">8</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">node_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;is_main_layer&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;classalias&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Conv&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;out_size&#39;</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                <span class="c1"># Make dense layers more visible</span>
                <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;classalias&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Dense&#39;</span><span class="p">:</span>
                    <span class="n">v</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;rect&#39;</span>
                    <span class="n">v</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale_dense_min</span>
                    <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;out_size&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">main_outsize</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">v</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;out_size&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale_dense_max</span>
                    <span class="k">elif</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;out_size&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">scale_dense_min</span><span class="p">:</span>
                        <span class="n">v</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale_dense_min</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;out_size&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">v</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;out_size&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;classalias&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Conv&#39;</span><span class="p">):</span>
                    <span class="n">v</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;stack&#39;</span>
                    <span class="c1"># v[&#39;shape&#39;] = &#39;rect&#39;</span>
                    <span class="n">v</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;out_size&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">v</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;out_size&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;rect&#39;</span>
                    <span class="n">v</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;out_size&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">v</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;out_size&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;rect&#39;</span>
                <span class="n">v</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">main_size_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">v</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">main_size_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># v[&#39;shape&#39;] = &#39;ellipse&#39;</span>
            <span class="n">v</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;rect&#39;</span>
            <span class="n">v</span><span class="p">[</span><span class="s1">&#39;style&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;rounded&#39;</span>
            <span class="n">v</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">v</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">key_order</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">layer_to_id</span><span class="p">,</span> <span class="n">layers</span><span class="p">)</span>
    <span class="n">node_dict</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dict_subset</span><span class="p">(</span><span class="n">node_dict</span><span class="p">,</span> <span class="n">key_order</span><span class="p">)</span>

    <span class="c1"># print(&#39;node_dict = &#39; + ut.repr3(node_dict))</span>

    <span class="c1"># Create the networkx graph structure</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">node_dict</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edge_list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">edge_attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="c1"># Add invisible structure</span>
    <span class="c1"># main_nodes = [key for key, val in</span>
    <span class="c1">#              nx.get_node_attributes(G, &#39;is_main_layer&#39;).items() if val]</span>

    <span class="n">main_children</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">odict</span><span class="p">()</span>

    <span class="c1"># for n1, n2 in ut.itertwo(main_nodes):</span>
    <span class="c1">#    print(&#39;n1, n2 = %r %r&#39; % (n1, n2))</span>
    <span class="c1">#    import utool</span>
    <span class="c1">#    utool.embed()</span>
    <span class="c1">#    children = ut.nx_all_nodes_between(G, n1, n2)</span>
    <span class="c1">#    if n1 in children:</span>
    <span class="c1">#        children.remove(n1)</span>
    <span class="c1">#    if n2 in children:</span>
    <span class="c1">#        children.remove(n2)</span>
    <span class="c1">#    main_children[n1] = children</span>

    <span class="c1">#    #pass</span>
    <span class="c1"># main_children[main_nodes[-1]] = []</span>

    <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">main_nodes</span><span class="p">:</span>
        <span class="n">main_children</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Main nodes only place constraints on nodes in the next main group.</span>
        <span class="c1"># Not their own</span>
        <span class="n">next_main</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="s1">&#39;group&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n1</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">bfs_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">n1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">next_main</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">main_nodes</span><span class="p">:</span>
                    <span class="n">next_main</span> <span class="o">=</span> <span class="n">n2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n2</span><span class="p">][</span><span class="s1">&#39;group&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n1</span>
                    <span class="n">main_children</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">descendants</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">next_main</span><span class="p">)):</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n2</span><span class="p">][</span><span class="s1">&#39;group&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n1</span>
                    <span class="n">main_children</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>

    <span class="c1"># Custom positioning</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="c1"># print(&#39;main_children = %s&#39; % (ut.repr3(main_children),))</span>

    <span class="c1"># main_nodes = ut.isect(list(nx.topological_sort(G)), main_nodes)</span>
    <span class="n">xpad</span> <span class="o">=</span> <span class="n">main_size_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.3</span>
    <span class="n">ypad</span> <span class="o">=</span> <span class="n">main_size_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.3</span>

    <span class="c1"># Draw each main node, and then put its children under it</span>
    <span class="c1"># Then move to the left and draw the next main node.</span>
    <span class="n">cumwidth</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">main_nodes</span><span class="p">:</span>
        <span class="n">cumheight</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">maxwidth</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="s1">&#39;width&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">main_children</span><span class="p">[</span><span class="n">n1</span><span class="p">]:</span>
            <span class="n">maxwidth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxwidth</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n2</span><span class="p">][</span><span class="s1">&#39;width&#39;</span><span class="p">])</span>

        <span class="n">cumwidth</span> <span class="o">+=</span> <span class="n">xpad</span>
        <span class="n">cumwidth</span> <span class="o">+=</span> <span class="n">maxwidth</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="o">+</span> <span class="n">cumwidth</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">cumheight</span><span class="p">])</span>
        <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="s1">&#39;pos&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="s1">&#39;pin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;true&#39;</span>

        <span class="n">height</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="s1">&#39;height&#39;</span><span class="p">]</span>
        <span class="n">cumheight</span> <span class="o">+=</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">main_children</span><span class="p">[</span><span class="n">n1</span><span class="p">]:</span>
            <span class="n">height</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n2</span><span class="p">][</span><span class="s1">&#39;height&#39;</span><span class="p">]</span>
            <span class="n">cumheight</span> <span class="o">+=</span> <span class="n">ypad</span>
            <span class="n">cumheight</span> <span class="o">+=</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="o">+</span> <span class="n">cumwidth</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">cumheight</span><span class="p">])</span>
            <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n2</span><span class="p">][</span><span class="s1">&#39;pos&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span>
            <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n2</span><span class="p">][</span><span class="s1">&#39;pin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;true&#39;</span>
            <span class="n">cumheight</span> <span class="o">+=</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="n">cumwidth</span> <span class="o">+=</span> <span class="n">maxwidth</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="c1"># Pin everybody</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;pin&#39;</span><span class="p">,</span> <span class="s1">&#39;true&#39;</span><span class="p">)</span>
    <span class="n">layoutkw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">&#39;neato&#39;</span><span class="p">,</span> <span class="n">splines</span><span class="o">=</span><span class="s1">&#39;line&#39;</span><span class="p">)</span>
    <span class="c1"># layoutkw = dict(prog=&#39;neato&#39;, splines=&#39;spline&#39;)</span>
    <span class="n">layoutkw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">&#39;neato&#39;</span><span class="p">,</span> <span class="n">splines</span><span class="o">=</span><span class="s1">&#39;ortho&#39;</span><span class="p">)</span>
    <span class="n">G_</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># delete lables for positioning</span>
    <span class="n">_labels</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">G_</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">)</span>
    <span class="n">ut</span><span class="o">.</span><span class="n">nx_delete_node_attr</span><span class="p">(</span><span class="n">G_</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">)</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G_</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">nolayout</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">nolayout</span><span class="p">:</span>
        <span class="n">G_</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G_</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">layout_info</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">nx_agraph_layout</span><span class="p">(</span><span class="n">G_</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">layoutkw</span><span class="p">)</span>  <span class="c1"># NOQA</span>
    <span class="c1"># reset labels</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nolayout</span><span class="p">:</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G_</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="n">_labels</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">show_nx</span><span class="p">(</span><span class="n">G_</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">arrow_width</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="s1">&#39;custom&#39;</span><span class="p">,</span> <span class="n">fnum</span><span class="o">=</span><span class="n">fnum</span><span class="p">)</span>  <span class="c1"># NOQA</span>
    <span class="c1"># pt.adjust_subplots(top=1, bot=0, left=0, right=1)</span>
    <span class="n">pt</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span></div>


<div class="viewcode-block" id="pydot_to_image"><a class="viewcode-back" href="../../wbia_cnn.html#wbia_cnn.draw_net.pydot_to_image">[docs]</a><span class="k">def</span> <span class="nf">pydot_to_image</span><span class="p">(</span><span class="n">pydot_graph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        http://stackoverflow.com/questions/4596962/display-graph-without-saving-using-pydot</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
    <span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="n">StringIO</span>

    <span class="c1"># from cStringIO import StringIO</span>
    <span class="n">png_str</span> <span class="o">=</span> <span class="n">pydot_graph</span><span class="o">.</span><span class="n">create_png</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">&#39;dot&#39;</span><span class="p">)</span>
    <span class="n">sio</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
    <span class="n">sio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">png_str</span><span class="p">)</span>
    <span class="n">sio</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">pil_img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">sio</span><span class="p">)</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pil_img</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;RGB&#39;</span><span class="p">))</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># to bgr</span>
    <span class="n">pil_img</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">sio</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">img</span></div>


<span class="c1"># def make_architecture_image(layers, **kwargs):</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    Args:</span>
<span class="c1">#        layers (list): List of the layers, as obtained from lasagne.layers.get_all_layers</span>

<span class="c1">#    Kwargs:</span>
<span class="c1">#        see docstring of make_architecture_pydot_graph for other options</span>

<span class="c1">#    References:</span>
<span class="c1">#        http://stackoverflow.com/questions/4596962/display-graph-without-saving-using-pydot</span>

<span class="c1">#    CommandLine:</span>
<span class="c1">#        python -m wbia_cnn.draw_net --test-make_architecture_image --show</span>

<span class="c1">#    Example:</span>
<span class="c1">#        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="c1">#        &gt;&gt;&gt; from wbia_cnn.draw_net import *  # NOQA</span>
<span class="c1">#        &gt;&gt;&gt; from wbia_cnn import models</span>
<span class="c1">#        &gt;&gt;&gt; model = models.SiameseCenterSurroundModel(autoinit=True)</span>
<span class="c1">#        &gt;&gt;&gt; #model = models.DummyModel(autoinit=True)</span>
<span class="c1">#        &gt;&gt;&gt; layers = model.get_all_layers()</span>
<span class="c1">#        &gt;&gt;&gt; # execute function</span>
<span class="c1">#        &gt;&gt;&gt; kwargs = {}</span>
<span class="c1">#        &gt;&gt;&gt; img = make_architecture_image(layers, **kwargs)</span>
<span class="c1">#        &gt;&gt;&gt; print(img.shape)</span>
<span class="c1">#        &gt;&gt;&gt; ut.quit_if_noshow()</span>
<span class="c1">#        &gt;&gt;&gt; import plottool as pt</span>
<span class="c1">#        &gt;&gt;&gt; pt.imshow(img)</span>
<span class="c1">#        &gt;&gt;&gt; ut.show_if_requested()</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    # from IPython.display import Image  # needed to render in notebook</span>
<span class="c1">#    pydot_graph = make_architecture_pydot_graph(layers, **kwargs)</span>
<span class="c1">#    img = pydot_to_image(pydot_graph)</span>
<span class="c1">#    return img</span>


<span class="c1"># def imwrite_arch(layers, fpath, **kwargs):</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    Draws a network diagram to a file</span>

<span class="c1">#    Args:</span>
<span class="c1">#        layers (list): List of the layers, as obtained from lasagne.layers.get_all_layers</span>
<span class="c1">#        fpath (str): The fpath to save output to.</span>

<span class="c1">#        Kwargs:</span>
<span class="c1">#            see docstring of make_architecture_pydot_graph for other options</span>

<span class="c1">#    CommandLine:</span>
<span class="c1">#        python -m wbia_cnn.draw_net --test-imwrite_arch --show</span>

<span class="c1">#    Example:</span>
<span class="c1">#        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="c1">#        &gt;&gt;&gt; from wbia_cnn.draw_net import *  # NOQA</span>
<span class="c1">#        &gt;&gt;&gt; from wbia_cnn import models</span>
<span class="c1">#        &gt;&gt;&gt; #model = models.DummyModel(autoinit=True)</span>
<span class="c1">#        &gt;&gt;&gt; model = models.SiameseCenterSurroundModel(autoinit=True)</span>
<span class="c1">#        &gt;&gt;&gt; layers = model.get_all_layers()</span>
<span class="c1">#        &gt;&gt;&gt; fpath = ut.unixjoin(ut.ensure_app_resource_dir(&#39;wbia_cnn&#39;), &#39;tmp.png&#39;)</span>
<span class="c1">#        &gt;&gt;&gt; # execute function</span>
<span class="c1">#        &gt;&gt;&gt; imwrite_arch(layers, fpath)</span>
<span class="c1">#        &gt;&gt;&gt; ut.quit_if_noshow()</span>
<span class="c1">#        &gt;&gt;&gt; ut.startfile(fpath)</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    pydot_graph = make_architecture_pydot_graph(layers, **kwargs)</span>

<span class="c1">#    ext = fpath[fpath.rfind(&#39;.&#39;) + 1:]</span>
<span class="c1">#    with open(fpath, &#39;w&#39;) as fid:</span>
<span class="c1">#        fid.write(pydot_graph.create(format=ext))</span>


<div class="viewcode-block" id="occlusion_heatmap"><a class="viewcode-back" href="../../wbia_cnn.html#wbia_cnn.draw_net.occlusion_heatmap">[docs]</a><span class="k">def</span> <span class="nf">occlusion_heatmap</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">square_length</span><span class="o">=</span><span class="mi">7</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An occlusion test that checks an image for its critical parts.</span>
<span class="sd">    In this function, a square part of the image is occluded (i.e. set</span>
<span class="sd">    to 0) and then the net is tested for its propensity to predict the</span>
<span class="sd">    correct label. One should expect that this propensity shrinks of</span>
<span class="sd">    critical parts of the image are occluded. If not, this indicates</span>
<span class="sd">    overfitting.</span>
<span class="sd">    Depending on the depth of the net and the size of the image, this</span>
<span class="sd">    function may take awhile to finish, since one prediction for each</span>
<span class="sd">    pixel of the image is made.</span>
<span class="sd">    Currently, all color channels are occluded at the same time. Also,</span>
<span class="sd">    this does not really work if images are randomly distorted by the</span>
<span class="sd">    batch iterator.</span>
<span class="sd">    See paper: Zeiler, Fergus 2013</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    net : NeuralNet instance</span>
<span class="sd">      The neural net to test.</span>
<span class="sd">    x : np.array</span>
<span class="sd">      The input data, should be of shape (1, c, x, y). Only makes</span>
<span class="sd">      sense with image data.</span>
<span class="sd">    target : int</span>
<span class="sd">      The true value of the image. If the net makes several</span>
<span class="sd">      predictions, say 10 classes, this indicates which one to look</span>
<span class="sd">      at.</span>
<span class="sd">    square_length : int (default=7)</span>
<span class="sd">      The length of the side of the square that occludes the image.</span>
<span class="sd">      Must be an odd number.</span>
<span class="sd">    Results</span>
<span class="sd">    -------</span>
<span class="sd">    heat_array : np.array (with same size as image)</span>
<span class="sd">      An 2D np.array that at each point (i, j) contains the predicted</span>
<span class="sd">      probability of the correct class if the image is occluded by a</span>
<span class="sd">      square with center (i, j).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">Lasagne.lasagne.layers</span> <span class="kn">import</span> <span class="n">get_output_shape</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;This function requires the input data to be of &#39;</span>
            <span class="s1">&#39;shape (1, c, x, y), instead got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">square_length</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Square length has to be an odd number, instead &#39;</span>
            <span class="s1">&#39;got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">square_length</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">num_classes</span> <span class="o">=</span> <span class="n">get_output_shape</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">layers_</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">bs</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">heat_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">s0</span><span class="p">,</span> <span class="n">s1</span><span class="p">))</span>
    <span class="n">pad</span> <span class="o">=</span> <span class="n">square_length</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">x_occluded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">s1</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">s0</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">))</span>

    <span class="c1"># generate occluded images</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s0</span><span class="p">):</span>
        <span class="c1"># batch s1 occluded images for faster prediction</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s1</span><span class="p">):</span>
            <span class="n">x_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">pad</span><span class="p">,</span> <span class="n">pad</span><span class="p">),</span> <span class="p">(</span><span class="n">pad</span><span class="p">,</span> <span class="n">pad</span><span class="p">)),</span> <span class="s1">&#39;constant&#39;</span><span class="p">)</span>
            <span class="n">x_pad</span><span class="p">[:,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">square_length</span><span class="p">,</span> <span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="n">square_length</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">x_occluded</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_pad</span><span class="p">[:,</span> <span class="n">pad</span><span class="p">:</span><span class="o">-</span><span class="n">pad</span><span class="p">,</span> <span class="n">pad</span><span class="p">:</span><span class="o">-</span><span class="n">pad</span><span class="p">]</span>
        <span class="n">y_proba</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">predict_proba_Xb</span><span class="p">(</span><span class="n">x_occluded</span><span class="p">)</span>
        <span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_proba</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">)</span>

    <span class="c1"># from predicted probabilities, pick only those of target class</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s0</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s1</span><span class="p">):</span>
            <span class="n">heat_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">target</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">heat_array</span></div>


<div class="viewcode-block" id="_plot_heat_map"><a class="viewcode-back" href="../../wbia_cnn.html#wbia_cnn.draw_net._plot_heat_map">[docs]</a><span class="k">def</span> <span class="nf">_plot_heat_map</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">Xb</span><span class="p">,</span> <span class="n">figsize</span><span class="p">,</span> <span class="n">get_heat_image</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">plottool</span> <span class="k">as</span> <span class="nn">pt</span>

    <span class="k">if</span> <span class="n">Xb</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;This function requires the input data to be of &#39;</span>
            <span class="s1">&#39;shape (b, c, x, y), instead got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Xb</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">num_images</span> <span class="o">=</span> <span class="n">Xb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">figsize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">figsize</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num_images</span> <span class="o">*</span> <span class="n">figsize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">figs</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">num_images</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="o">.</span><span class="n">flatten</span><span class="p">():</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_images</span><span class="p">):</span>
        <span class="n">heat_img</span> <span class="o">=</span> <span class="n">get_heat_image</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">Xb</span><span class="p">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">n</span><span class="p">)</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span> <span class="k">if</span> <span class="n">num_images</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">axes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">Xb</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="o">-</span><span class="n">img</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;image&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="o">-</span><span class="n">heat_img</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Reds&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;critical parts&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="o">-</span><span class="n">img</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="o">-</span><span class="n">heat_img</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Reds&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;super-imposed&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pt</span><span class="o">.</span><span class="n">plt</span></div>


<div class="viewcode-block" id="plot_occlusion"><a class="viewcode-back" href="../../wbia_cnn.html#wbia_cnn.draw_net.plot_occlusion">[docs]</a><span class="k">def</span> <span class="nf">plot_occlusion</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">Xb</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">square_length</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;Plot which parts of an image are particularly import for the</span>
<span class="sd">    net to classify the image correctly.</span>
<span class="sd">    See paper: Zeiler, Fergus 2013</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    net : NeuralNet instance</span>
<span class="sd">      The neural net to test.</span>
<span class="sd">    Xb : numpy.array</span>
<span class="sd">      The input data, should be of shape (b, c, 0, 1). Only makes</span>
<span class="sd">      sense with image data.</span>
<span class="sd">    target : list or numpy.array of ints</span>
<span class="sd">      The true values of the image. If the net makes several</span>
<span class="sd">      predictions, say 10 classes, this indicates which one to look</span>
<span class="sd">      at. If more than one sample is passed to Xb, each of them needs</span>
<span class="sd">      its own target.</span>
<span class="sd">    square_length : int (default=7)</span>
<span class="sd">      The length of the side of the square that occludes the image.</span>
<span class="sd">      Must be an odd number.</span>
<span class="sd">    figsize : tuple (int, int)</span>
<span class="sd">      Size of the figure.</span>
<span class="sd">    Plots</span>
<span class="sd">    -----</span>
<span class="sd">    Figure with 3 subplots: the original image, the occlusion heatmap,</span>
<span class="sd">    and both images super-imposed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_plot_heat_map</span><span class="p">(</span>
        <span class="n">net</span><span class="p">,</span>
        <span class="n">Xb</span><span class="p">,</span>
        <span class="n">figsize</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">net</span><span class="p">,</span> <span class="n">Xb</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">occlusion_heatmap</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">Xb</span><span class="p">,</span> <span class="n">target</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">square_length</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="plot_saliency"><a class="viewcode-back" href="../../wbia_cnn.html#wbia_cnn.draw_net.plot_saliency">[docs]</a><span class="k">def</span> <span class="nf">plot_saliency</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">Xb</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
    <span class="k">def</span> <span class="nf">saliency_map</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">Xb</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">theano.tensor</span> <span class="k">as</span> <span class="nn">T</span>
        <span class="kn">from</span> <span class="nn">Lasagne.lasagne.objectives</span> <span class="kn">import</span> <span class="n">binary_crossentropy</span>

        <span class="n">score</span> <span class="o">=</span> <span class="o">-</span><span class="n">binary_crossentropy</span><span class="p">(</span><span class="n">output</span><span class="p">[:,</span> <span class="n">pred</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">heat_map_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="nb">input</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">({</span><span class="nb">input</span><span class="p">:</span> <span class="n">Xb</span><span class="p">}))</span>
        <span class="k">return</span> <span class="n">heat_map_</span>

    <span class="k">def</span> <span class="nf">saliency_map_net</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">Xb</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">Lasagne.lasagne.layers</span> <span class="kn">import</span> <span class="n">get_output</span>

        <span class="nb">input</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">layers_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_var</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">get_output</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">layers_</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">eval</span><span class="p">({</span><span class="nb">input</span><span class="p">:</span> <span class="n">Xb</span><span class="p">})</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">heat_map_</span> <span class="o">=</span> <span class="n">saliency_map</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">Xb</span><span class="p">)</span>
        <span class="n">heat_img</span> <span class="o">=</span> <span class="n">heat_map_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">heat_img</span>

    <span class="k">return</span> <span class="n">_plot_heat_map</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">Xb</span><span class="p">,</span> <span class="n">figsize</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">net</span><span class="p">,</span> <span class="n">Xb</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="o">-</span><span class="n">saliency_map_net</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">Xb</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dream"><a class="viewcode-back" href="../../wbia_cnn.html#wbia_cnn.draw_net.Dream">[docs]</a><span class="k">class</span> <span class="nc">Dream</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    https://groups.google.com/forum/#!topic/lasagne-users/UxZpNthZfq0</span>
<span class="sd">    http://arxiv.org/pdf/1312.6034.pdf</span>
<span class="sd">    http://igva2012.wikispaces.asu.edu/file/view/Erhan+2009+Visualizing+higher+layer+features+of+a+deep+network.pdf</span>

<span class="sd">    #TODO</span>
<span class="sd">    https://arxiv.org/pdf/1605.09304v3.pdf</span>

<span class="sd">    Class model visualization. Sort of like a deep-dream</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m wbia_cnn.draw_net Dream --show</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; # Assumes mnist is trained</span>
<span class="sd">        &gt;&gt;&gt; from wbia_cnn.draw_net import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; from wbia_cnn.models import mnist</span>
<span class="sd">        &gt;&gt;&gt; model, dataset = mnist.testdata_mnist(dropout=.5)</span>
<span class="sd">        &gt;&gt;&gt; model.init_arch()</span>
<span class="sd">        &gt;&gt;&gt; model.load_model_state()</span>
<span class="sd">        &gt;&gt;&gt; target_labels = 3</span>
<span class="sd">        &gt;&gt;&gt; ut.quit_if_noshow()</span>
<span class="sd">        &gt;&gt;&gt; import plottool as pt</span>
<span class="sd">        &gt;&gt;&gt; #pt.qt4ensure()</span>
<span class="sd">        &gt;&gt;&gt; dream = Dream(model, niters=200)</span>
<span class="sd">        &gt;&gt;&gt; img = dream.make_class_images(target_labels)</span>
<span class="sd">        &gt;&gt;&gt; pt.imshow(img)</span>
<span class="sd">        &gt;&gt;&gt; ut.show_if_requested()</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Dream.saliency"><a class="viewcode-back" href="../../wbia_cnn.html#wbia_cnn.draw_net.Dream.saliency">[docs]</a>    <span class="k">def</span> <span class="nf">saliency</span><span class="p">(</span><span class="n">dream</span><span class="p">,</span> <span class="n">Xb</span><span class="p">,</span> <span class="n">yb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        num = 10</span>
<span class="sd">        Xb = model.prepare_data(X_test[0:num])</span>
<span class="sd">        yb = y_test[0:num]</span>

<span class="sd">        dpath = &#39;&#39;</span>
<span class="sd">        dataset = None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dpath</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span>

        <span class="kn">import</span> <span class="nn">theano.tensor</span> <span class="k">as</span> <span class="nn">T</span>
        <span class="kn">from</span> <span class="nn">Lasagne</span> <span class="kn">import</span> <span class="n">lasagne</span>
        <span class="kn">import</span> <span class="nn">vtool</span> <span class="k">as</span> <span class="nn">vt</span>
        <span class="kn">import</span> <span class="nn">theano</span>

        <span class="n">model</span> <span class="o">=</span> <span class="n">dream</span><span class="o">.</span><span class="n">model</span>

        <span class="c1"># Use current weights to find the score of a particular class</span>
        <span class="n">Xb_shared</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">Xb</span><span class="p">)</span>
        <span class="n">yb_shared</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">yb</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>

        <span class="c1"># Get the final layer and remove the softmax nonlinearity to access the</span>
        <span class="c1"># pre-activation. (Softmax encourages minimization of other classes)</span>
        <span class="kn">import</span> <span class="nn">copy</span>

        <span class="c1"># softmax = copy.copy(model.output_layer)</span>
        <span class="c1"># softmax.nonlinearity = lasagne.nonlinearities.identity</span>
        <span class="n">softmax</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">output_layer</span><span class="p">)</span>

        <span class="n">class_probs</span> <span class="o">=</span> <span class="n">lasagne</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">get_output</span><span class="p">(</span><span class="n">softmax</span><span class="p">,</span> <span class="n">Xb_shared</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># werid way to index into position of target</span>
        <span class="n">flat_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">yb_shared</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">class_probs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">yb_shared</span>
        <span class="n">class_probs_target</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">class_probs</span><span class="p">)[</span><span class="n">flat_idx</span><span class="p">]</span>

        <span class="c1"># Get derivative of scores for the target class wrt the input</span>
        <span class="n">d_score_wrt_input</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">class_probs_target</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">Xb_shared</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d_score_wrt_input</span><span class="o">.</span><span class="n">eval</span><span class="p">())</span>
        <span class="n">saliency</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">outs</span> <span class="o">=</span> <span class="n">saliency</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">Xb</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Xb</span><span class="p">)):</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">yb</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">norm01</span><span class="p">(</span><span class="n">outs</span><span class="p">[</span><span class="n">count</span><span class="p">])</span>
            <span class="n">overlay</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">blend_images_multiply</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span>

            <span class="n">vt</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span>
                <span class="n">join</span><span class="p">(</span><span class="n">dpath</span><span class="p">,</span> <span class="s1">&#39;out</span><span class="si">%d</span><span class="s1">_A_image_t=</span><span class="si">%s</span><span class="s1">.jpg&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">y</span><span class="p">)),</span>
                <span class="n">vt</span><span class="o">.</span><span class="n">rectify_to_uint8</span><span class="p">(</span><span class="n">img</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">vt</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span>
                <span class="n">join</span><span class="p">(</span><span class="n">dpath</span><span class="p">,</span> <span class="s1">&#39;out</span><span class="si">%d</span><span class="s1">_B_heat_t=</span><span class="si">%s</span><span class="s1">.jpg&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">y</span><span class="p">)),</span>
                <span class="n">vt</span><span class="o">.</span><span class="n">rectify_to_uint8</span><span class="p">(</span><span class="n">out</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">vt</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span>
                <span class="n">join</span><span class="p">(</span><span class="n">dpath</span><span class="p">,</span> <span class="s1">&#39;out</span><span class="si">%d</span><span class="s1">_C_overlay_t=</span><span class="si">%s</span><span class="s1">.jpg&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">y</span><span class="p">)),</span>
                <span class="n">vt</span><span class="o">.</span><span class="n">rectify_to_uint8</span><span class="p">(</span><span class="n">overlay</span><span class="p">),</span>
            <span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="n">dream</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="n">niters</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">update_rate</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span> <span class="n">weight_decay</span><span class="o">=</span><span class="mf">1e-5</span>
    <span class="p">):</span>
        <span class="n">dream</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="n">dream</span><span class="o">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">init</span>
        <span class="n">dream</span><span class="o">.</span><span class="n">niters</span> <span class="o">=</span> <span class="n">niters</span>
        <span class="n">dream</span><span class="o">.</span><span class="n">update_rate</span> <span class="o">=</span> <span class="n">update_rate</span>
        <span class="n">dream</span><span class="o">.</span><span class="n">weight_decay</span> <span class="o">=</span> <span class="n">weight_decay</span>
        <span class="c1"># FIXME: cached vars assumes not much changes</span>
        <span class="n">dream</span><span class="o">.</span><span class="n">shared_images</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">dream</span><span class="o">.</span><span class="n">step_fn</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Dream.make_class_images"><a class="viewcode-back" href="../../wbia_cnn.html#wbia_cnn.draw_net.Dream.make_class_images">[docs]</a>    <span class="k">def</span> <span class="nf">make_class_images</span><span class="p">(</span><span class="n">dream</span><span class="p">,</span> <span class="n">target_labels</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">theano</span>
        <span class="kn">from</span> <span class="nn">theano</span> <span class="kn">import</span> <span class="n">tensor</span> <span class="k">as</span> <span class="n">T</span>  <span class="c1"># NOQA</span>
        <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

        <span class="n">was_scalar</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">ut</span><span class="o">.</span><span class="n">isiterable</span><span class="p">(</span><span class="n">target_labels</span><span class="p">)</span>
        <span class="n">target_labels</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">ensure_iterable</span><span class="p">(</span><span class="n">target_labels</span><span class="p">)</span>

        <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># We are forcing a batch size for this visualization</span>
            <span class="n">input_shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target_labels</span><span class="p">),)</span> <span class="o">+</span> <span class="n">dream</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">input_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Maybe some cnn layers cant take variable batches?</span>
            <span class="n">input_shape</span> <span class="o">=</span> <span class="n">dream</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">input_shape</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">input_shape</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_labels</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">,</span> <span class="s1">&#39;batch size too small&#39;</span>

        <span class="n">initial_state</span> <span class="o">=</span> <span class="n">dream</span><span class="o">.</span><span class="n">_make_init_state</span><span class="p">()</span>

        <span class="c1"># make image a shared variable that you can update</span>
        <span class="k">if</span> <span class="n">dream</span><span class="o">.</span><span class="n">shared_images</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dream</span><span class="o">.</span><span class="n">shared_images</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dream</span><span class="o">.</span><span class="n">shared_images</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dream</span><span class="o">.</span><span class="n">step_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dream</span><span class="o">.</span><span class="n">step_fn</span> <span class="o">=</span> <span class="n">dream</span><span class="o">.</span><span class="n">_make_objective</span><span class="p">(</span><span class="n">dream</span><span class="o">.</span><span class="n">shared_images</span><span class="p">,</span> <span class="n">target_labels</span><span class="p">)</span>

        <span class="c1"># Optimize objective via backpropogation for a few iterations</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">ut</span><span class="o">.</span><span class="n">ProgIter</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dream</span><span class="o">.</span><span class="n">niters</span><span class="p">),</span> <span class="n">lbl</span><span class="o">=</span><span class="s1">&#39;making class model img&#39;</span><span class="p">,</span> <span class="n">bs</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">dream</span><span class="o">.</span><span class="n">step_fn</span><span class="p">()</span>
            <span class="c1"># print(&#39;objective = %r&#39; % (objective,))</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">dream</span><span class="o">.</span><span class="n">_postprocess_class_image</span><span class="p">(</span>
            <span class="n">dream</span><span class="o">.</span><span class="n">shared_images</span><span class="p">,</span> <span class="n">target_labels</span><span class="p">,</span> <span class="n">was_scalar</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="Dream._make_init_state"><a class="viewcode-back" href="../../wbia_cnn.html#wbia_cnn.draw_net.Dream._make_init_state">[docs]</a>    <span class="k">def</span> <span class="nf">_make_init_state</span><span class="p">(</span><span class="n">dream</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        CommandLine:</span>
<span class="sd">            python -m wbia_cnn.draw_net _make_init_state --show</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">            &gt;&gt;&gt; # Assumes mnist is trained</span>
<span class="sd">            &gt;&gt;&gt; from wbia_cnn.draw_net import *  # NOQA</span>
<span class="sd">            &gt;&gt;&gt; from wbia_cnn.models import mnist</span>
<span class="sd">            &gt;&gt;&gt; model, dataset = mnist.testdata_mnist(dropout=.5)</span>
<span class="sd">            &gt;&gt;&gt; model.init_arch()</span>
<span class="sd">            &gt;&gt;&gt; dream = Dream(model, init=&#39;rgauss&#39;, niters=200)</span>
<span class="sd">            &gt;&gt;&gt; ut.quit_if_noshow()</span>
<span class="sd">            &gt;&gt;&gt; import plottool as pt</span>
<span class="sd">            &gt;&gt;&gt; import vtool as vt</span>
<span class="sd">            &gt;&gt;&gt; #pt.qt4ensure()</span>
<span class="sd">            &gt;&gt;&gt; initial_state = dream._make_init_state().transpose((0, 2, 3, 1))[0]</span>
<span class="sd">            &gt;&gt;&gt; pt.imshow(initial_state, pnum=(1, 2, 1), fnum=1)</span>
<span class="sd">            &gt;&gt;&gt; pt.imshow(vt.norm01(initial_state), pnum=(1, 2, 2), fnum=1)</span>
<span class="sd">            &gt;&gt;&gt; ut.show_if_requested()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">init</span> <span class="o">=</span> <span class="n">dream</span><span class="o">.</span><span class="n">init</span>
        <span class="n">input_shape</span> <span class="o">=</span> <span class="n">dream</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">input_shape</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">input_shape</span>

        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">init</span> <span class="o">==</span> <span class="s1">&#39;zeros&#39;</span><span class="p">:</span>
            <span class="c1"># intializing to zeros seems to do nothing on mnist data</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">input_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">init</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;rand&#39;</span><span class="p">,</span> <span class="s1">&#39;random&#39;</span><span class="p">]:</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="o">*</span><span class="n">input_shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">init</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;randn&#39;</span><span class="p">]:</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">input_shape</span><span class="p">))</span> <span class="o">/</span> <span class="mi">6</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">initial_state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">init</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;gauss&#39;</span><span class="p">]:</span>
            <span class="kn">import</span> <span class="nn">vtool</span> <span class="k">as</span> <span class="nn">vt</span>

            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">vt</span><span class="o">.</span><span class="n">gaussian_patch</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="p">)]]</span> <span class="o">*</span> <span class="n">b</span>
            <span class="p">)</span>
            <span class="c1"># initial_state /= initial_state.max()</span>
        <span class="k">elif</span> <span class="n">init</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;rgauss&#39;</span><span class="p">]:</span>
            <span class="kn">import</span> <span class="nn">vtool</span> <span class="k">as</span> <span class="nn">vt</span>

            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">vt</span><span class="o">.</span><span class="n">gaussian_patch</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="p">)]]</span> <span class="o">*</span> <span class="n">b</span>
            <span class="p">)</span>
            <span class="c1"># initial_state /= initial_state.max()</span>
            <span class="n">raug</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">input_shape</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">initial_state</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">/</span> <span class="mi">12</span><span class="p">)</span>
            <span class="n">initial_state</span> <span class="o">+=</span> <span class="n">raug</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">initial_state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">init</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;perlin&#39;</span><span class="p">]:</span>
            <span class="kn">import</span> <span class="nn">vtool</span> <span class="k">as</span> <span class="nn">vt</span>

            <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">input_shape</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">vt</span><span class="o">.</span><span class="n">perlin_noise</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="p">)]]</span> <span class="o">*</span> <span class="n">b</span>
            <span class="p">)</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">initial_state</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span>
        <span class="n">initial_state</span> <span class="o">=</span> <span class="n">initial_state</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">initial_state</span></div>

<div class="viewcode-block" id="Dream._make_objective"><a class="viewcode-back" href="../../wbia_cnn.html#wbia_cnn.draw_net.Dream._make_objective">[docs]</a>    <span class="k">def</span> <span class="nf">_make_objective</span><span class="p">(</span><span class="n">dream</span><span class="p">,</span> <span class="n">shared_images</span><span class="p">,</span> <span class="n">target_labels</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The goal is to optimize</span>
<span class="sd">        S_c = score of class c before softmax nonlinearity</span>
<span class="sd">        argmax_{I} S_c(I) - \lambda \elltwo{I}</span>
<span class="sd">        max(S_c(I) - lambda * norm(I, 2))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">Lasagne</span> <span class="kn">import</span> <span class="n">lasagne</span>
        <span class="kn">import</span> <span class="nn">copy</span>
        <span class="kn">import</span> <span class="nn">theano</span>
        <span class="kn">from</span> <span class="nn">theano</span> <span class="kn">import</span> <span class="n">tensor</span> <span class="k">as</span> <span class="n">T</span>  <span class="c1"># NOQA</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Making dream objective&#39;</span><span class="p">)</span>
        <span class="c1"># Get the final layer and remove the softmax nonlinearity to access the</span>
        <span class="c1"># pre-activation. (Softmax encourages minimization of other classes)</span>
        <span class="n">softmax</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">dream</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">output_layer</span><span class="p">)</span>
        <span class="n">softmax</span><span class="o">.</span><span class="n">nonlinearity</span> <span class="o">=</span> <span class="n">lasagne</span><span class="o">.</span><span class="n">nonlinearities</span><span class="o">.</span><span class="n">identity</span>

        <span class="c1"># Overwrite lasagne&#39;s InputLayer with the image</span>
        <span class="c1"># Build expression to represent class scores wrt the image</span>
        <span class="n">class_scores</span> <span class="o">=</span> <span class="n">lasagne</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">get_output</span><span class="p">(</span>
            <span class="n">softmax</span><span class="p">,</span> <span class="n">shared_images</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># Get the class score that represents our class of interest</span>
        <span class="c1"># simultaniously generate as many classes as were requested.</span>
        <span class="n">max_term_batch</span> <span class="o">=</span> <span class="p">[</span><span class="n">class_scores</span><span class="p">[</span><span class="n">bx</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="k">for</span> <span class="n">bx</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_labels</span><span class="p">)]</span>
        <span class="n">max_term</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">max_term_batch</span><span class="p">)</span>

        <span class="c1"># Get the squared L2 norm of the image values</span>
        <span class="n">flat_img</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">shared_images</span><span class="p">,</span> <span class="p">(</span><span class="n">shared_images</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">T</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shared_images</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
        <span class="p">)</span>
        <span class="n">reg_term_batch</span> <span class="o">=</span> <span class="p">(</span><span class="n">flat_img</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">reg_term</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reg_term_batch</span><span class="p">)</span>

        <span class="n">objective</span> <span class="o">=</span> <span class="n">max_term</span> <span class="o">-</span> <span class="n">dream</span><span class="o">.</span><span class="n">weight_decay</span> <span class="o">*</span> <span class="n">reg_term</span>

        <span class="c1"># Compute the gradient of the maximization objective</span>
        <span class="c1"># with respect to the image</span>
        <span class="n">grads</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="n">wrt</span><span class="o">=</span><span class="n">shared_images</span><span class="p">)</span>

        <span class="c1"># compile a function that does this update</span>
        <span class="n">step_fn</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">function</span><span class="p">(</span>
            <span class="n">inputs</span><span class="o">=</span><span class="p">[],</span>
            <span class="c1"># outputs could be empty, but returning objective allows us to</span>
            <span class="c1"># monitor progress</span>
            <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">objective</span><span class="p">],</span>
            <span class="n">updates</span><span class="o">=</span><span class="p">{</span><span class="n">shared_images</span><span class="p">:</span> <span class="n">shared_images</span> <span class="o">+</span> <span class="n">dream</span><span class="o">.</span><span class="n">update_rate</span> <span class="o">*</span> <span class="n">grads</span><span class="p">},</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">step_fn</span></div>

<div class="viewcode-block" id="Dream._postprocess_class_image"><a class="viewcode-back" href="../../wbia_cnn.html#wbia_cnn.draw_net.Dream._postprocess_class_image">[docs]</a>    <span class="k">def</span> <span class="nf">_postprocess_class_image</span><span class="p">(</span><span class="n">dream</span><span class="p">,</span> <span class="n">shared_images</span><span class="p">,</span> <span class="n">target_labels</span><span class="p">,</span> <span class="n">was_scalar</span><span class="p">):</span>
        <span class="c1"># return final state of the image</span>
        <span class="n">Xb</span> <span class="o">=</span> <span class="n">shared_images</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">Xb</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_labels</span><span class="p">)]</span>
        <span class="kn">import</span> <span class="nn">vtool</span> <span class="k">as</span> <span class="nn">vt</span>  <span class="c1"># NOQA</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">out_</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">norm01</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">*</span> <span class="mi">255</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">was_scalar</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="Dream.generate_class_images"><a class="viewcode-back" href="../../wbia_cnn.html#wbia_cnn.draw_net.Dream.generate_class_images">[docs]</a>    <span class="k">def</span> <span class="nf">generate_class_images</span><span class="p">(</span><span class="n">dream</span><span class="p">,</span> <span class="n">target_labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        import plottool as pt</span>
<span class="sd">        fnum = None</span>
<span class="sd">        kw = dict(init=&#39;gauss&#39;, niters=500, update_rate=.05, weight_decay=1e-4)</span>
<span class="sd">        target_labels = list(range(model.output_dims))</span>
<span class="sd">        dream = draw_net.Dream(model, **kw)</span>
<span class="sd">        target_labels = 8</span>
<span class="sd">        images = list(dream.generate_class_images(target_labels))</span>

<span class="sd">        vid = vt.make_video(images, &#39;dynimg.pimj&#39;, fps=1, is_color=False, format=&#39;PIM1&#39;)</span>
<span class="sd">        vid = vt.make_video2(images, &#39;dynimg&#39;)</span>

<span class="sd">        import matplotlib.pyplot as plt</span>
<span class="sd">        ims = []</span>
<span class="sd">        for img in imgs:</span>
<span class="sd">            im = plt.imshow(img[:, :, 0], interpolation=&#39;nearest&#39;, cmap=&#39;gray&#39;)</span>
<span class="sd">            ims.append([im])</span>

<span class="sd">        import matplotlib.animation as animation</span>
<span class="sd">        fig = plt.figure()</span>
<span class="sd">        ani = animation.ArtistAnimation(fig, ims, interval=50, blit=True,</span>
<span class="sd">                                        repeat_delay=1000)</span>
<span class="sd">        ani.save(&#39;dynamic_images.mp4&#39;)</span>
<span class="sd">        ut.startfile(&#39;dynamic_images.mp4&#39;)</span>
<span class="sd">        plt.show()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">theano</span>
        <span class="kn">from</span> <span class="nn">theano</span> <span class="kn">import</span> <span class="n">tensor</span> <span class="k">as</span> <span class="n">T</span>  <span class="c1"># NOQA</span>
        <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

        <span class="n">input_shape</span> <span class="o">=</span> <span class="n">dream</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">input_shape</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">input_shape</span>
        <span class="n">was_scalar</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">ut</span><span class="o">.</span><span class="n">isiterable</span><span class="p">(</span><span class="n">target_labels</span><span class="p">)</span>
        <span class="n">target_labels</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">ensure_iterable</span><span class="p">(</span><span class="n">target_labels</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_labels</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">,</span> <span class="s1">&#39;batch size too small&#39;</span>
        <span class="n">initial_state</span> <span class="o">=</span> <span class="n">dream</span><span class="o">.</span><span class="n">_make_init_state</span><span class="p">()</span>
        <span class="n">shared_images</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">initial_state</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
        <span class="n">step_fn</span> <span class="o">=</span> <span class="n">dream</span><span class="o">.</span><span class="n">_make_objective</span><span class="p">(</span><span class="n">shared_images</span><span class="p">,</span> <span class="n">target_labels</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">dream</span><span class="o">.</span><span class="n">_postprocess_class_image</span><span class="p">(</span><span class="n">shared_images</span><span class="p">,</span> <span class="n">target_labels</span><span class="p">,</span> <span class="n">was_scalar</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">out</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">ut</span><span class="o">.</span><span class="n">ProgIter</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dream</span><span class="o">.</span><span class="n">niters</span><span class="p">),</span> <span class="n">lbl</span><span class="o">=</span><span class="s1">&#39;class dream&#39;</span><span class="p">,</span> <span class="n">bs</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">step_fn</span><span class="p">()</span>
            <span class="c1"># objective = step_fn()</span>
            <span class="c1"># print(&#39;objective = %r&#39; % (objective,))</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">dream</span><span class="o">.</span><span class="n">_postprocess_class_image</span><span class="p">(</span><span class="n">shared_images</span><span class="p">,</span> <span class="n">target_labels</span><span class="p">,</span> <span class="n">was_scalar</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">out</span></div></div>


<div class="viewcode-block" id="show_saliency_heatmap"><a class="viewcode-back" href="../../wbia_cnn.html#wbia_cnn.draw_net.show_saliency_heatmap">[docs]</a><span class="k">def</span> <span class="nf">show_saliency_heatmap</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    https://github.com/dnouri/nolearn/blob/master/nolearn/lasagne/visualize.py</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; # Assumes mnist is trained</span>
<span class="sd">        &gt;&gt;&gt; from wbia_cnn.draw_net import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; from wbia_cnn import ingest_data</span>
<span class="sd">        &gt;&gt;&gt; from wbia_cnn.models import MNISTModel</span>
<span class="sd">        &gt;&gt;&gt; dataset = ingest_data.grab_mnist_category_dataset()</span>
<span class="sd">        &gt;&gt;&gt; model = MNISTModel(batch_size=128, data_shape=dataset.data_shape,</span>
<span class="sd">        &gt;&gt;&gt;                    name=&#39;bnorm&#39;,</span>
<span class="sd">        &gt;&gt;&gt;                    output_dims=len(dataset.unique_labels),</span>
<span class="sd">        &gt;&gt;&gt;                    batch_norm=True,</span>
<span class="sd">        &gt;&gt;&gt;                    dataset_dpath=dataset.dataset_dpath)</span>
<span class="sd">        &gt;&gt;&gt; model.encoder = None</span>
<span class="sd">        &gt;&gt;&gt; model.init_arch()</span>
<span class="sd">        &gt;&gt;&gt; model.load_model_state()</span>
<span class="sd">        &gt;&gt;&gt; import plottool as pt</span>
<span class="sd">        &gt;&gt;&gt; pt.qt4ensure()</span>
<span class="sd">        &gt;&gt;&gt; show_saliency_heatmap(model, dataset)</span>
<span class="sd">        &gt;&gt;&gt; ut.show_if_requested()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dataset</span><span class="o">.</span><span class="n">has_subset</span><span class="p">(</span><span class="s1">&#39;valid&#39;</span><span class="p">):</span>
        <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">subset</span><span class="p">(</span><span class="s1">&#39;train&#39;</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">X_valid</span><span class="p">,</span> <span class="n">y_valid</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_prefit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">X_valid</span><span class="p">,</span> <span class="n">y_valid</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">subset</span><span class="p">(</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>
    <span class="n">net</span> <span class="o">=</span> <span class="n">model</span>
    <span class="n">num</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">X_valid</span><span class="p">[</span><span class="n">start</span> <span class="p">:</span> <span class="n">start</span> <span class="o">+</span> <span class="n">num</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y_valid</span><span class="p">[</span><span class="n">start</span> <span class="p">:</span> <span class="n">start</span> <span class="o">+</span> <span class="n">num</span><span class="p">]</span>
    <span class="n">Xb</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">prepare_input</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">plot_occlusion</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">Xb</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>
    <span class="c1"># plot_saliency(net, Xb)</span>


<div class="viewcode-block" id="show_convolutional_weights"><a class="viewcode-back" href="../../wbia_cnn.html#wbia_cnn.draw_net.show_convolutional_weights">[docs]</a><span class="k">def</span> <span class="nf">show_convolutional_weights</span><span class="p">(</span>
    <span class="n">all_weights</span><span class="p">,</span> <span class="n">use_color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">144</span><span class="p">,</span> <span class="n">fnum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pnum</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        all_weights (?):</span>
<span class="sd">        use_color (bool):</span>
<span class="sd">        limit (int):</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m wbia_cnn.draw_net --test-show_convolutional_weights --show</span>
<span class="sd">        python -m wbia_cnn.draw_net --test-show_convolutional_weights --show --index=1</span>

<span class="sd">        # Need to fit mnist first</span>
<span class="sd">        python -m wbia_cnn _ModelFitting.fit:1 --vd</span>


<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; # Assumes mnist is trained</span>
<span class="sd">        &gt;&gt;&gt; from wbia_cnn.draw_net import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; from wbia_cnn import ingest_data</span>
<span class="sd">        &gt;&gt;&gt; from wbia_cnn.models import MNISTModel</span>
<span class="sd">        &gt;&gt;&gt; dataset = ingest_data.grab_mnist_category_dataset()</span>
<span class="sd">        &gt;&gt;&gt; model = MNISTModel(batch_size=128, data_shape=dataset.data_shape,</span>
<span class="sd">        &gt;&gt;&gt;                    name=&#39;bnorm&#39;,</span>
<span class="sd">        &gt;&gt;&gt;                    output_dims=len(dataset.unique_labels),</span>
<span class="sd">        &gt;&gt;&gt;                    batch_norm=True,</span>
<span class="sd">        &gt;&gt;&gt;                    dataset_dpath=dataset.dataset_dpath)</span>
<span class="sd">        &gt;&gt;&gt; model.encoder = None</span>
<span class="sd">        &gt;&gt;&gt; model.init_arch()</span>
<span class="sd">        &gt;&gt;&gt; model.load_model_state()</span>
<span class="sd">        &gt;&gt;&gt; nn_layers = model.get_all_layers()</span>
<span class="sd">        &gt;&gt;&gt; weighted_layers = [layer for layer in nn_layers if hasattr(layer, &#39;W&#39;)]</span>
<span class="sd">        &gt;&gt;&gt; all_weights = weighted_layers[0].W.get_value()</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;all_weights.shape = %r&#39; % (all_weights.shape,))</span>
<span class="sd">        &gt;&gt;&gt; use_color = None</span>
<span class="sd">        &gt;&gt;&gt; limit = 64</span>
<span class="sd">        &gt;&gt;&gt; fig = show_convolutional_weights(all_weights, use_color, limit)</span>
<span class="sd">        &gt;&gt;&gt; ut.quit_if_noshow()</span>
<span class="sd">        &gt;&gt;&gt; import plottool as pt</span>
<span class="sd">        &gt;&gt;&gt; pt.qt4ensure()</span>
<span class="sd">        &gt;&gt;&gt; fig = show_convolutional_weights(all_weights, use_color, limit)</span>
<span class="sd">        &gt;&gt;&gt; ut.show_if_requested()</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from wbia_cnn.draw_net import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; from wbia_cnn import models</span>
<span class="sd">        &gt;&gt;&gt; from Lasagne.lasagne import layers</span>
<span class="sd">        &gt;&gt;&gt; model = models.SiameseCenterSurroundModel(autoinit=True)</span>
<span class="sd">        &gt;&gt;&gt; output_layer = model.get_output_layer()</span>
<span class="sd">        &gt;&gt;&gt; nn_layers = layers.get_all_layers(output_layer)</span>
<span class="sd">        &gt;&gt;&gt; weighted_layers = [layer for layer in nn_layers if hasattr(layer, &#39;W&#39;)]</span>
<span class="sd">        &gt;&gt;&gt; index = ut.get_argval(&#39;--index&#39;, type_=int, default=0)</span>
<span class="sd">        &gt;&gt;&gt; all_weights = weighted_layers[index].W.get_value()</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;all_weights.shape = %r&#39; % (all_weights.shape,))</span>
<span class="sd">        &gt;&gt;&gt; use_color = None</span>
<span class="sd">        &gt;&gt;&gt; limit = 64</span>
<span class="sd">        &gt;&gt;&gt; fig = show_convolutional_weights(all_weights, use_color, limit)</span>
<span class="sd">        &gt;&gt;&gt; ut.show_if_requested()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">plottool</span> <span class="k">as</span> <span class="nn">pt</span>

    <span class="k">if</span> <span class="n">fnum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fnum</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">next_fnum</span><span class="p">()</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">fnum</span><span class="o">=</span><span class="n">fnum</span><span class="p">,</span> <span class="n">pnum</span><span class="o">=</span><span class="n">pnum</span><span class="p">,</span> <span class="n">docla</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">num</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">all_weights</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">use_color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Try to infer if use_color should be shown</span>
        <span class="n">use_color</span> <span class="o">=</span> <span class="n">channels</span> <span class="o">==</span> <span class="mi">3</span>

    <span class="n">stacked_img</span> <span class="o">=</span> <span class="n">make_conv_weight_image</span><span class="p">(</span><span class="n">all_weights</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
    <span class="c1"># ax = fig.add_subplot(111)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stacked_img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">stacked_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">stacked_img</span> <span class="o">=</span> <span class="n">stacked_img</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">stacked_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">pt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">stacked_img</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="make_conv_weight_image"><a class="viewcode-back" href="../../wbia_cnn.html#wbia_cnn.draw_net.make_conv_weight_image">[docs]</a><span class="k">def</span> <span class="nf">make_conv_weight_image</span><span class="p">(</span><span class="n">all_weights</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">144</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; just makes the image ndarray of the weights &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">vtool</span> <span class="k">as</span> <span class="nn">vt</span>
    <span class="kn">import</span> <span class="nn">cv2</span>

    <span class="c1"># Try to infer if use_color should be shown</span>
    <span class="n">num</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">all_weights</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1"># Try to infer if use_color should be shown</span>
    <span class="n">use_color</span> <span class="o">=</span> <span class="n">channels</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="c1"># non-use_color features need to be flattened</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_color</span><span class="p">:</span>
        <span class="n">all_weights_</span> <span class="o">=</span> <span class="n">all_weights</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num</span> <span class="o">*</span> <span class="n">channels</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># convert from theano to cv2 BGR</span>
        <span class="n">all_weights_</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">convert_theano_images_to_cv2_images</span><span class="p">(</span><span class="n">all_weights</span><span class="p">)</span>
        <span class="c1"># convert from BGR to RGB</span>
        <span class="n">all_weights_</span> <span class="o">=</span> <span class="n">all_weights_</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># cv2.cvtColor(all_weights_[-1], cv2.COLOR_BGR2RGB)</span>

    <span class="c1"># Limit all_weights_</span>
    <span class="c1"># num = all_weights_.shape[0]</span>
    <span class="n">num</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">channels</span> <span class="o">=</span> <span class="n">all_weights_</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">:</span>
        <span class="n">all_weights_</span> <span class="o">=</span> <span class="n">all_weights_</span><span class="p">[:</span><span class="n">limit</span><span class="p">]</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">all_weights_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Convert weight values to image values</span>
    <span class="n">normalize_individually</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">normalize_individually</span><span class="p">:</span>
        <span class="c1"># Normalize each feature individually</span>
        <span class="n">all_max</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">multiaxis_reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">,</span> <span class="n">all_weights_</span><span class="p">,</span> <span class="n">startaxis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">all_min</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">multiaxis_reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">,</span> <span class="n">all_weights_</span><span class="p">,</span> <span class="n">startaxis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">all_domain</span> <span class="o">=</span> <span class="n">all_max</span> <span class="o">-</span> <span class="n">all_min</span>
        <span class="n">extra_dims</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_weights_</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">broadcaster</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="n">extra_dims</span>
        <span class="n">all_features</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">all_weights_</span> <span class="o">-</span> <span class="n">all_min</span><span class="p">[</span><span class="n">broadcaster</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mf">255.0</span> <span class="o">/</span> <span class="n">all_domain</span><span class="p">[</span><span class="n">broadcaster</span><span class="p">])</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Normalize jointly across all filters</span>
        <span class="n">_max</span> <span class="o">=</span> <span class="n">all_weights_</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">_min</span> <span class="o">=</span> <span class="n">all_weights_</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">_domain</span> <span class="o">=</span> <span class="n">_max</span> <span class="o">-</span> <span class="n">_min</span>
        <span class="n">all_features</span> <span class="o">=</span> <span class="p">((</span><span class="n">all_weights_</span> <span class="o">-</span> <span class="n">_min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">255.0</span> <span class="o">/</span> <span class="n">_domain</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

    <span class="c1"># import scipy.misc</span>
    <span class="c1"># resize feature, give them a border, and stack them together</span>
    <span class="n">new_height</span><span class="p">,</span> <span class="n">new_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
    <span class="n">nbp_</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># num border pixels</span>
    <span class="n">_resized_features</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="n">new_width</span><span class="p">,</span> <span class="n">new_height</span><span class="p">),</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">INTER_NEAREST</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">all_features</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="n">resized_features</span> <span class="o">=</span> <span class="n">_resized_features</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">new_height</span><span class="p">,</span> <span class="n">new_width</span><span class="p">,</span> <span class="n">channels</span><span class="p">)</span>
    <span class="n">border_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">new_height</span> <span class="o">+</span> <span class="p">(</span><span class="n">nbp_</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span> <span class="n">new_width</span> <span class="o">+</span> <span class="p">(</span><span class="n">nbp_</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span> <span class="n">channels</span><span class="p">)</span>
    <span class="n">bordered_features</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">border_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">resized_features</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">bordered_features</span><span class="p">[:,</span> <span class="n">nbp_</span><span class="p">:</span><span class="o">-</span><span class="n">nbp_</span><span class="p">,</span> <span class="n">nbp_</span><span class="p">:</span><span class="o">-</span><span class="n">nbp_</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">resized_features</span>
    <span class="c1"># img_list = bordered_features</span>
    <span class="n">stacked_img</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">stack_square_images</span><span class="p">(</span><span class="n">bordered_features</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stacked_img</span></div>


<div class="viewcode-block" id="output_confusion_matrix"><a class="viewcode-back" href="../../wbia_cnn.html#wbia_cnn.draw_net.output_confusion_matrix">[docs]</a><span class="k">def</span> <span class="nf">output_confusion_matrix</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">results_path</span><span class="p">,</span> <span class="n">test_results</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; currently hacky implementation, fix it later &quot;&quot;&quot;</span>
    <span class="n">loss</span><span class="p">,</span> <span class="n">accu_test</span><span class="p">,</span> <span class="n">prob_list</span><span class="p">,</span> <span class="n">auglbl_list</span><span class="p">,</span> <span class="n">pred_list</span><span class="p">,</span> <span class="n">conf_list</span> <span class="o">=</span> <span class="n">test_results</span>
    <span class="c1"># Output confusion matrix</span>
    <span class="n">mapping_fn</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mapping_fn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;label_order_mapping&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="c1"># TODO: THIS NEEDS TO BE FIXED</span>
    <span class="n">label_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;output_dims&#39;</span><span class="p">)))</span>
    <span class="c1"># Encode labels if avaialble</span>
    <span class="c1"># encoder = kwargs.get(&#39;encoder&#39;, None)</span>
    <span class="n">encoder</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;encoder&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">encoder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">label_list</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">label_list</span><span class="p">)</span>
    <span class="c1"># Make confusion matrix (pass X to write out failed cases)</span>
    <span class="n">show_confusion_matrix</span><span class="p">(</span>
        <span class="n">auglbl_list</span><span class="p">,</span> <span class="n">pred_list</span><span class="p">,</span> <span class="n">label_list</span><span class="p">,</span> <span class="n">results_path</span><span class="p">,</span> <span class="n">mapping_fn</span><span class="p">,</span> <span class="n">X_test</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="save_confusion_matrix"><a class="viewcode-back" href="../../wbia_cnn.html#wbia_cnn.draw_net.save_confusion_matrix">[docs]</a><span class="k">def</span> <span class="nf">save_confusion_matrix</span><span class="p">(</span>
    <span class="n">results_path</span><span class="p">,</span> <span class="n">correct_y</span><span class="p">,</span> <span class="n">predict_y</span><span class="p">,</span> <span class="n">category_list</span><span class="p">,</span> <span class="n">mapping_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_x</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="kn">import</span> <span class="nn">plottool</span> <span class="k">as</span> <span class="nn">pt</span>

    <span class="n">fig</span> <span class="o">=</span> <span class="n">show_confusion_matrix</span><span class="p">(</span>
        <span class="n">correct_y</span><span class="p">,</span> <span class="n">predict_y</span><span class="p">,</span> <span class="n">category_list</span><span class="p">,</span> <span class="n">mapping_fn</span><span class="o">=</span><span class="n">mapping_fn</span><span class="p">,</span> <span class="n">data_x</span><span class="o">=</span><span class="n">data_x</span>
    <span class="p">)</span>
    <span class="n">output_fpath</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">results_path</span><span class="p">,</span> <span class="s1">&#39;confusion.png&#39;</span><span class="p">)</span>
    <span class="n">pt</span><span class="o">.</span><span class="n">save_figure</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">fpath</span><span class="o">=</span><span class="n">output_fpath</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output_fpath</span></div>


<div class="viewcode-block" id="show_confusion_matrix"><a class="viewcode-back" href="../../wbia_cnn.html#wbia_cnn.draw_net.show_confusion_matrix">[docs]</a><span class="k">def</span> <span class="nf">show_confusion_matrix</span><span class="p">(</span>
    <span class="n">correct_y</span><span class="p">,</span> <span class="n">predict_y</span><span class="p">,</span> <span class="n">category_list</span><span class="p">,</span> <span class="n">results_path</span><span class="p">,</span> <span class="n">mapping_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_x</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given the correct and predict labels, show the confusion matrix</span>

<span class="sd">    Args:</span>
<span class="sd">        correct_y (list of int): the list of correct labels</span>
<span class="sd">        predict_y (list of int): the list of predict assigned labels</span>
<span class="sd">        category_list (list of str): the category list of all categories</span>

<span class="sd">    Displays:</span>
<span class="sd">        matplotlib: graph of the confusion matrix</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>

<span class="sd">    TODO FIXME and simplify</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="kn">import</span> <span class="nn">cv2</span>

    <span class="n">confused_examples</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">results_path</span><span class="p">,</span> <span class="s1">&#39;confused&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">confused_examples</span><span class="p">):</span>
            <span class="n">ut</span><span class="o">.</span><span class="n">remove_dirs</span><span class="p">(</span><span class="n">confused_examples</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ut</span><span class="o">.</span><span class="n">ensuredir</span><span class="p">(</span><span class="n">confused_examples</span><span class="p">)</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">category_list</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mapping_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Identity</span>
        <span class="n">category_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">category_list</span><span class="p">)}</span>
        <span class="n">category_list_</span> <span class="o">=</span> <span class="n">category_list</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">category_mapping</span> <span class="o">=</span> <span class="n">mapping_fn</span><span class="p">(</span><span class="n">category_list</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="p">[</span><span class="n">category</span> <span class="ow">in</span> <span class="n">category_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">category_list</span><span class="p">]</span>
        <span class="p">),</span> <span class="s1">&#39;Not all categories are mapped&#39;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">category_mapping</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">values</span>
        <span class="p">),</span> <span class="s1">&#39;Mapped categories have a duplicate assignment&#39;</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">values</span><span class="p">,</span> <span class="s1">&#39;Mapped categories must have a 0 index&#39;</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">category_mapping</span><span class="o">.</span><span class="n">iteritems</span><span class="p">())</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">category_list_</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">temp</span><span class="p">]</span>

    <span class="n">confidences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
    <span class="n">counters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">correct</span><span class="p">,</span> <span class="n">predict</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">correct_y</span><span class="p">,</span> <span class="n">predict_y</span><span class="p">)):</span>
        <span class="c1"># Ensure type</span>
        <span class="n">correct</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">correct</span><span class="p">)</span>
        <span class="n">predict</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">predict</span><span class="p">)</span>
        <span class="c1"># Get the &quot;text&quot; label</span>
        <span class="n">example_correct_label</span> <span class="o">=</span> <span class="n">category_list</span><span class="p">[</span><span class="n">correct</span><span class="p">]</span>
        <span class="n">example_predict_label</span> <span class="o">=</span> <span class="n">category_list</span><span class="p">[</span><span class="n">predict</span><span class="p">]</span>
        <span class="c1"># Perform any mapping that needs to be done</span>
        <span class="n">correct_</span> <span class="o">=</span> <span class="n">category_mapping</span><span class="p">[</span><span class="n">example_correct_label</span><span class="p">]</span>
        <span class="n">predict_</span> <span class="o">=</span> <span class="n">category_mapping</span><span class="p">[</span><span class="n">example_predict_label</span><span class="p">]</span>
        <span class="c1"># Add to the confidence matrix</span>
        <span class="n">confidences</span><span class="p">[</span><span class="n">correct_</span><span class="p">][</span><span class="n">predict_</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">data_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">correct_</span> <span class="o">!=</span> <span class="n">predict_</span><span class="p">:</span>
            <span class="n">example</span> <span class="o">=</span> <span class="n">data_x</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">example_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">^SEEN_INCORRECTLY_AS^</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">example_correct_label</span><span class="p">,</span>
                <span class="n">example_predict_label</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">example_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">counters</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">counters</span><span class="p">[</span><span class="n">example_name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="n">counters</span><span class="p">[</span><span class="n">example_name</span><span class="p">]</span>
            <span class="n">counters</span><span class="p">[</span><span class="n">example_name</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">example_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">^</span><span class="si">%d</span><span class="s1">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">example_name</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>
            <span class="n">example_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">confused_examples</span><span class="p">,</span> <span class="n">example_name</span><span class="p">)</span>
            <span class="c1"># TODO: make write confused examples function</span>
            <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">example_path</span><span class="p">,</span> <span class="n">example</span><span class="p">)</span>

    <span class="n">row_sums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">confidences</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">norm_conf</span> <span class="o">=</span> <span class="p">(</span><span class="n">confidences</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">row_sums</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">norm_conf</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">jet</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">confidences</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">])),</span>
                <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span>
                <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="n">cb</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>  <span class="c1"># NOQA</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">category_list_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">size</span><span class="p">],</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">category_list_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">size</span><span class="p">])</span>
    <span class="n">margin_small</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">margin_large</span> <span class="o">=</span> <span class="mf">0.9</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span>
        <span class="n">left</span><span class="o">=</span><span class="n">margin_small</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">margin_large</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="n">margin_small</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="n">margin_large</span>
    <span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Predicted&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Correct&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fig</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CommandLine:</span>
<span class="sd">        python -m wbia_cnn.draw_net</span>
<span class="sd">        python -m wbia_cnn.draw_net --allexamples</span>
<span class="sd">        python -m wbia_cnn.draw_net --allexamples --noface --nosrc</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">multiprocessing</span>

    <span class="n">multiprocessing</span><span class="o">.</span><span class="n">freeze_support</span><span class="p">()</span>  <span class="c1"># for win32</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>  <span class="c1"># NOQA</span>

    <span class="n">ut</span><span class="o">.</span><span class="n">doctest_funcs</span><span class="p">()</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">wbia-cnn</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../wbia_cnn.html">wbia_cnn package</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  <li><a href="../wbia_cnn.html">wbia_cnn</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Wild Me.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>