
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>jscatter.cloudscattering &#8212; Jscatter 1.2.7 documentation</title>
    <link rel="stylesheet" href="../../_static//default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    
    <link rel="shortcut icon" href="../../_static/Jscatter-32x-32.png"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Jscatter 1.2.7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">jscatter.cloudscattering</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for jscatter.cloudscattering</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># written by Ralf Biehl at the Forschungszentrum Jülich ,</span>
<span class="c1"># Jülich Center for Neutron Science 1 and Institute of Complex Systems 1</span>
<span class="c1">#    Jscatter is a program to read, analyse and plot data</span>
<span class="c1">#    Copyright (C) 2015-2019  Ralf Biehl</span>
<span class="c1">#</span>
<span class="c1">#    This program is free software: you can redistribute it and/or modify</span>
<span class="c1">#    it under the terms of the GNU General Public License as published by</span>
<span class="c1">#    the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1">#    (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1">#    This program is distributed in the hope that it will be useful,</span>
<span class="c1">#    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1">#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1">#    GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1">#    You should have received a copy of the GNU General Public License</span>
<span class="c1">#    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>

<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Cloud can represent any object described by a cloud of (different) scatterers with</span>
<span class="sd">scattering amplitudes as constant, sphere scattering amplitude,</span>
<span class="sd">Gaussian scattering amplitude or explicitly given ones.</span>

<span class="sd">The scattering of a cloud can represent the scattering of a **cluster of particles** with polydispersity</span>
<span class="sd">and position distortion according to root mean square displacements (rms).</span>
<span class="sd">Polydispersity and rms displacements are randomly changed within the explicit orientational average to represent</span>
<span class="sd">an ensemble average (opposite to the time average of a single cluster).</span>

<span class="sd">The cloud can represent a **particle lattice** in a nano particle to describe the Bragg peaks or be used as a kind</span>
<span class="sd">of volume integrations for **arbitrary shaped particles**.</span>
<span class="sd">Additional complex objects composed of different types of subparticles can be created.</span>
<span class="sd">E.g a hollow sphere decorated by Gaussian chains. See `cloudscattering examples` below.</span>

<span class="sd">The scattering is calculated by explicit calculation with a spherical average to allow inclusion of</span>
<span class="sd">polydispersity, position distortion and because its faster for large numbers of particles (&gt;1000).</span>
<span class="sd">For small number of particles the Debye equation can be used but without polydispersity and position distortion.</span>
<span class="sd">See :py:func:`~.cloudscattering.cloudScattering`</span>

<span class="sd">Note:</span>
<span class="sd">    Models that are build by positioning of differently shaped particles might depict</span>
<span class="sd">    approximations of the real scattering as overlaps are not considered or</span>
<span class="sd">    changes of specific configurations due to the presence of another particle might change.</span>
<span class="sd">    As an example we look at  :py:func:`~.formfactor.sphereGaussianCorona`. The Gaussian coils have overlap</span>
<span class="sd">    with the inner sphere and for high aggregation numbers the coil overlap is not described correctly.</span>

<span class="sd">    Nevertheless these approximations might be useful to describe general features of a scattering pattern.</span>
<span class="sd">    Additional one might consider that analytic models as a e.g. a sphere are approximations itself neglecting</span>
<span class="sd">    surface roughness, interfaces, deviations from symmetry or anisotropy and</span>
<span class="sd">    break down if a length scale of internal building blocks as e.g. atoms is reached.</span>

<span class="sd">**Cloudscattering examples**</span>

<span class="sd">Check the source</span>
<span class="sd"> - :py:func:`~.formfactor.decoratedCoreShell`</span>
<span class="sd"> - :py:func:`~.formfactor.linearPearls`</span>
<span class="sd"> - :py:func:`~.formfactor.superball`</span>
<span class="sd"> - :py:func:`~.structurefactor.latticeStructureFactor`</span>
<span class="sd"> - :ref:`A nano cube build of different lattices`</span>

<span class="sd">Cloudscattering results are normalized by :math:`I_0=(\sum b_i)^2` to equal one for q=0</span>
<span class="sd">(except for polydispersity).</span>

<span class="sd">===============</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numbers</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">formel</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">parallel</span>

<span class="kn">from</span> <span class="nn">.dataarray</span> <span class="kn">import</span> <span class="n">dataArray</span> <span class="k">as</span> <span class="n">dA</span>
<span class="kn">from</span> <span class="nn">.dataarray</span> <span class="kn">import</span> <span class="n">dataList</span> <span class="k">as</span> <span class="n">dL</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">fscatter</span>

    <span class="n">useFortran</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">useFortran</span> <span class="o">=</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">_fa_sphere</span><span class="p">(</span><span class="n">qr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    scattering amplitude sphere with catching the zero</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fa</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">qr</span><span class="p">)</span>
    <span class="n">qr1</span><span class="o">=</span><span class="n">qr</span><span class="p">[</span><span class="n">qr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">fa</span><span class="p">[</span><span class="n">qr</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">/</span> <span class="n">qr1</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">qr1</span><span class="p">)</span> <span class="o">-</span> <span class="n">qr1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">qr1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">fa</span>


<span class="k">def</span> <span class="nf">_fa_coil</span><span class="p">(</span><span class="n">qrg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    qrg is array dim 1</span>
<span class="sd">    fa_coil**2 is Debye function see [2]_ in  sphereCoreShellGaussianCorona</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">qrg</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">fa</span><span class="p">[</span><span class="n">qrg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">qrg</span><span class="p">[</span><span class="n">qrg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]))</span> <span class="o">/</span> <span class="p">(</span><span class="n">qrg</span><span class="p">[</span><span class="n">qrg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">fa</span>


<span class="k">def</span> <span class="nf">_scattering</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rms</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ffpolydispersity</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Coherent scattering of objects at positions r in direction point on sphere with length (radius) q</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    point : point on unit sphere 3 x 1</span>
<span class="sd">    q : float</span>
<span class="sd">        q vector length</span>
<span class="sd">    r : array  N x 3</span>
<span class="sd">        vector of objekt positions</span>
<span class="sd">    blength : array N</span>
<span class="sd">        scattering length of objects</span>
<span class="sd">    iff : Nxinteger</span>
<span class="sd">        indices of form factors</span>
<span class="sd">    formfactoramp ixN array</span>
<span class="sd">        formfactoramp of all objects</span>
<span class="sd">    rms: float</span>
<span class="sd">        position rms</span>
<span class="sd">    ffpolydispersity : float</span>
<span class="sd">        size rms by scaling of size</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    F(Q)*F(Q).conj() , F(Q).sum()</span>

<span class="sd">    pure numpy way as option</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">useFortran</span><span class="p">:</span>
        <span class="c1"># speedup 2.41 : 1.1  for  cloudScattering(q,insidegrid) on ncpu=1 comparing this fortran and below</span>
        <span class="c1"># speedup  38.5 : 4.75   for  ncpu=6 and 9261 points with rms&gt;0</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">fscatter</span><span class="o">.</span><span class="n">cloud</span><span class="o">.</span><span class="n">ffq</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="p">,</span> <span class="n">rms</span><span class="p">,</span> <span class="n">ffpolydispersity</span><span class="p">)</span>
        <span class="c1"># print(ret,point,r.shape)</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">%</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">ffpolydispersity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># normal distribution of size factor</span>
            <span class="n">sizerms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">ffpolydispersity</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># corresponding relative volume change</span>
            <span class="n">volrmsfactor</span> <span class="o">=</span> <span class="n">sizerms</span> <span class="o">**</span> <span class="mi">3</span>
            <span class="n">volrmsfactor</span><span class="p">[</span><span class="n">sizerms</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># interpolate with volume change weight</span>
            <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">blength</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">iff</span><span class="p">):</span>
                <span class="n">chose</span> <span class="o">=</span> <span class="n">iff</span> <span class="o">==</span> <span class="n">i</span>
                <span class="n">fa</span><span class="p">[</span><span class="n">chose</span><span class="p">]</span> <span class="o">=</span> <span class="n">volrmsfactor</span><span class="p">[</span><span class="n">chose</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">q</span> <span class="o">*</span> <span class="n">sizerms</span><span class="p">[</span><span class="n">chose</span><span class="p">],</span> <span class="n">formfactoramp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span>
                                                            <span class="n">formfactoramp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># interpolate the formfactoramp</span>
            <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">amp</span><span class="p">)</span> <span class="k">for</span> <span class="n">amp</span> <span class="ow">in</span> <span class="n">formfactoramp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
            <span class="n">fa</span> <span class="o">=</span> <span class="n">fa</span><span class="p">[</span><span class="n">iff</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">qx</span> <span class="o">=</span> <span class="n">q</span> <span class="o">*</span> <span class="n">point</span>
        <span class="k">if</span> <span class="n">rms</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">rms</span>
        <span class="n">iqr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,ji&#39;</span><span class="p">,</span> <span class="n">qx</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span>  <span class="c1"># 454 µs        iqr.shape 26135</span>
        <span class="n">beiqrsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,i&#39;</span><span class="p">,</span> <span class="n">blength</span> <span class="o">*</span> <span class="n">fa</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">iqr</span><span class="p">))</span>
        <span class="n">Sq</span> <span class="o">=</span> <span class="n">beiqrsum</span> <span class="o">*</span> <span class="n">beiqrsum</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>  <span class="c1"># 2 µs</span>
        <span class="k">return</span> <span class="n">q</span><span class="p">,</span> <span class="n">Sq</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">beiqrsum</span><span class="o">.</span><span class="n">real</span>


<span class="k">def</span> <span class="nf">_sphaverage_scattering</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rms</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ffpolydispersity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">relError</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Coherent scattering of objects at positions r in after oriental average.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q : float</span>
<span class="sd">        q vector length</span>
<span class="sd">    r : array  N x 3</span>
<span class="sd">        vector of objekt positions</span>
<span class="sd">    blength : array N</span>
<span class="sd">        scattering length of objects</span>
<span class="sd">    formfactoramp 2xN array</span>
<span class="sd">        formfactoramp of all objects</span>
<span class="sd">    rms: float</span>
<span class="sd">        position rms</span>
<span class="sd">    ffpolydispersity : float</span>
<span class="sd">        size rms by scaling of size</span>
<span class="sd">    relError : int</span>
<span class="sd">        determines number of points on Fibonacci lattice on sphere</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Q, &lt;F(Q)*F(Q).conj()&gt; , &lt;F(Q).sum()&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># call Fortran sphere average for ffq</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">fscatter</span><span class="o">.</span><span class="n">cloud</span><span class="o">.</span><span class="n">sphereaverage_ffq</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="p">,</span> <span class="n">rms</span><span class="p">,</span> <span class="n">ffpolydispersity</span><span class="p">,</span> <span class="n">relError</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_scattering_Debye</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Debye equation  definition as in _scattering</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">iff1</span> <span class="o">=</span> <span class="n">iff</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">q</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">blength</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="c1"># interpolate the formfactoramp</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">amp</span><span class="p">)</span> <span class="k">for</span> <span class="n">amp</span> <span class="ow">in</span> <span class="n">formfactoramp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>

    <span class="c1"># ()**2.sum()**0.5 to get absolute value |ri-rj|</span>
    <span class="n">qrij</span> <span class="o">=</span> <span class="n">q</span> <span class="o">*</span> <span class="p">((</span><span class="n">r</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>  <span class="c1"># 137 ms r.shape (1856, 3)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">qrij</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># 19 µs</span>
    <span class="n">sinoq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">qrij</span><span class="p">)</span> <span class="o">/</span> <span class="n">qrij</span>  <span class="c1"># 47.7 ms   still faster than np.sinc</span>
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">sinoq</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># 19.4 µs</span>
    <span class="n">Sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,j,ij-&gt;&#39;</span><span class="p">,</span> <span class="n">blength</span> <span class="o">*</span> <span class="n">fa</span><span class="p">[</span><span class="n">iff1</span><span class="p">],</span> <span class="n">blength</span> <span class="o">*</span> <span class="n">fa</span><span class="p">[</span><span class="n">iff1</span><span class="p">],</span> <span class="n">sinoq</span><span class="p">)</span>  <span class="c1"># 10.3 ms</span>
    <span class="k">return</span> <span class="n">Sq</span>


<div class="viewcode-block" id="cloudScattering"><a class="viewcode-back" href="../../formfactor.html#jscatter.cloudscattering.cloudScattering">[docs]</a><span class="k">def</span> <span class="nf">cloudScattering</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cloud</span><span class="p">,</span> <span class="n">relError</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">formfactor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">V</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rms</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ffpolydispersity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ncpu</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scattering of a cloud of scatterers with variable scattering length. Uses multiprocessing.</span>

<span class="sd">    Cloud can represent any object described by a cloud of scatterers with scattering amplitudes</span>
<span class="sd">    as constant, sphere scattering amplitude, Gaussian scattering amplitude or explicitly given one.</span>
<span class="sd">    The result is normalized by :math:`I_0=(\sum b_i)^2` to equal one for q=0 (except for polydispersity).</span>

<span class="sd">    - .I0 represents the forward scattering if :math:`b_i=b_vV_{unit cell}` with :math:`b_v` as</span>
<span class="sd">      scattering length density in the unit cell.</span>
<span class="sd">    - Remember that the atomic bond length are on the order 0.1-0.2 nm.</span>
<span class="sd">    - Methods to build clouds of scatterers e.g. a cube decorated with spheres at the corners can be</span>
<span class="sd">      found in :ref:`Lattice` with examples.</span>
<span class="sd">    - By default explicit spherical average is done. If rms and polydispersity are not needed the Debye-function</span>
<span class="sd">      can be used (for particle numbers&lt;1000 it is faster).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q : array, ndim= Nx1</span>
<span class="sd">         Radial wavevectors in 1/nm</span>
<span class="sd">    cloud : array Nx3 or Nx4 or Nx5</span>
<span class="sd">        - Center of mass positions (in nm) of the N scatterers in the cloud.</span>
<span class="sd">        - If given cloud[3] is the scattering length :math:`b_i` at positions cloud[:3], otherwise :math:`b=1`.</span>
<span class="sd">        - Ff given cloud[4] is the column index in formfactor for a specific scatterer.</span>
<span class="sd">        - To compare with material scattering length density :math:`b_v` use :math:`b=b_vV_{unit cell}` with</span>
<span class="sd">          :math:`b_v` as scattering length density and :math:`V_{unit cell}` as cloud unit cell volume.</span>
<span class="sd">    relError : float</span>
<span class="sd">        Determines calculation method.</span>
<span class="sd">         - relError&gt;1   Explicit calculation of spherical average with Fibonacci lattice on sphere</span>
<span class="sd">                        of 2*relError+1 points. Already 150 gives good results (see Examples)</span>
<span class="sd">         - 0&lt;relError&lt;1 Monte Carlo integration on sphere until changes in successive iterations</span>
<span class="sd">                        become smaller than relError.</span>
<span class="sd">                        (Monte carlo integration with pseudo random numbers, see sphereAverage).</span>
<span class="sd">                        This might take long for too small error.</span>
<span class="sd">         - relError=0   The Debye equation is used (no asymmetry factor beta, no rms, no ffpolydispersity).</span>
<span class="sd">                        Computation is of order :math:`N^2` opposite to above which is order :math:`N`.</span>
<span class="sd">                        For about 1000 particles same computing time,for 500 Debye is 4 times faster than above.</span>
<span class="sd">                        If beta, rms or polydispersity is needed use above.</span>
<span class="sd">    rms : float, default=0</span>
<span class="sd">        Root mean square displacement :math:`\langleu^2\rangle^{0.5} of the positions in cloud as</span>
<span class="sd">        random (Gaussian) displacements in nm.</span>
<span class="sd">         - Displacement u is randomly changed for each orientation in orientational average.</span>
<span class="sd">         - rms results in a Debye-Waller factor e.g. for crystal lattices.</span>
<span class="sd">         - Using a low number of displacements introduces noise on the model function because of bad sampling.</span>
<span class="sd">           To reduce this noise during fitting relError should be high (&gt;2000 for linearPearls) and the result might be</span>
<span class="sd">           smoothed.</span>
<span class="sd">    formfactor : None,&#39;gauss&#39;,&#39;sphere&#39;, array</span>
<span class="sd">        Gridpoint scattering amplitudes F_a(q) are described by:</span>
<span class="sd">         - None    : const scattering amplitude.</span>
<span class="sd">         - &#39;sphere&#39;: Sphere scattering amplitude according to [3]_ equal for all cloud points.</span>
<span class="sd">                     Parameter V is needed to determine :math:`R`.</span>
<span class="sd">                     The sphere radius is :math:`R=(\frac{3V}{4\pi})^{1/3}`</span>
<span class="sd">         - &#39;gauss&#39; : Gaussian function  :math:`b_i(q)=b V exp(-\pi V^{2/3}q^2)` according to [2]_</span>
<span class="sd">                     equal for all cloud points. The Gaussian shows no artificial minima compared to the sphere.</span>
<span class="sd">                     Parameter V needed to determine :math:`b_i`.</span>
<span class="sd">         - &#39;coil&#39; :  Polymer coil (ideal Gaussian chain) showing scattering according to Debye function.</span>
<span class="sd">                     Parameter V needed to determine :math:`R_g = (\frac{3V}{4\pi})^{1/3}`.</span>
<span class="sd">                     The scattering length is :math:`b_i = Nb_{monomer}` with monomer number :math:`N`</span>
<span class="sd">         - Explicit isotropic :math:`F_a(q)` as array with [q,fa1(q),fa2(q),fa3(q),....].</span>
<span class="sd">            - If multiple fai are given the index i for a cloud point needs to be given in cloud[4]</span>
<span class="sd">            - The normalized scattering amplitude fa for each cloud point is calculated as fa=fai/fai[0].</span>
<span class="sd">              Missing values are linear interpolated (np.interp), q values outside interval are mapped to qmin or qmax.</span>
<span class="sd">            - Explicit formfactors are assumed to be isotropic.</span>
<span class="sd">            - If the scattering amplitude is not known :math:`F_a(q) \approx F^{1/2}(q)`</span>
<span class="sd">              might be used as approximation for low Q.</span>
<span class="sd">    V : float, default=None</span>
<span class="sd">        Volume of the scatterers to determine scattering amplitude (see formfactor).</span>
<span class="sd">        Only needed for formfactor &#39;sphere&#39; and &#39;gauss&#39;.</span>
<span class="sd">    ffpolydispersity : float</span>
<span class="sd">        Polydispersity of the gridpoints in relative units for sphere, gauss, explicit.</span>
<span class="sd">        Assuming F(q*R) for each gridpoint F is scaled as F(q*f*R)  with f as normal distribution</span>
<span class="sd">        around 1 and standard deviation ffpolydispersity. The scattering length :math:`b` is scaled according</span>
<span class="sd">        to the respective volume change by f**3. (f&lt;0 is set to zero) assuming a volume scatterer.</span>
<span class="sd">        This results in a change of the forward scattering because of the stronger weight of larger objects.</span>
<span class="sd">    ncpu : int, default 0</span>
<span class="sd">        Number of cpus used in the pool for multiprocessing.</span>
<span class="sd">         - not given or 0 : all cpus are used</span>
<span class="sd">         - int&gt;0          : min(ncpu, mp.cpu_count)</span>
<span class="sd">         - int&lt;0          : ncpu not to use</span>
<span class="sd">         - 1              : single core usage for testing or comparing speed to Debye</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dataArray</span>
<span class="sd">        Columns [q, Pq, beta, fa]</span>
<span class="sd">         - Pq , formfactor , beta asymmetry factor, fa scattering amplitude</span>
<span class="sd">         - .I0 :          :math:`=I(q=0)=(\sum_N b_i)^2`</span>
<span class="sd">         - .sumblength :  :math:`=\sum_N b_i`</span>
<span class="sd">         - .formfactoramplitude   : formfactor amplitude of cloudpoints according to type for all q values.</span>
<span class="sd">         - .formfactoramplitude_q :  corresponding q values</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    We calculate the scattering amplitude :math:`F(q)` for :math:`N` particles in a volume :math:`V` with scattering</span>
<span class="sd">    length density :math:`b(r)`</span>

<span class="sd">    .. math:: F(q)= \int_V b(r) e^{i\mathbf{qr}} \mathrm{d}r  / \int_V b(r) \mathrm{d}r  =</span>
<span class="sd">                    \sum_N b_i(q) e^{i\mathbf{qr}}  / \sum_N b_i(0)</span>

<span class="sd">    with the  form factor :math:`P(Q)` after explicit orientational average :math:`&lt;&gt;`</span>

<span class="sd">    .. math:: P(Q)=&lt; F(q) \cdot F^*(q) &gt;=&lt; |F(q)|^2 &gt;</span>

<span class="sd">    The scattering intensity of a single object represented by the cloud is</span>

<span class="sd">    .. math:: I(Q)=P(Q) \cdot (\int_V b(r) \mathrm{d}r)^2</span>

<span class="sd">    beta is the asymmetry factor [1]_ :math:`beta =|&lt; F(q) &gt;|^2 / &lt; |F(q)|^2 &gt;`</span>

<span class="sd">    One has to expect a peak at :math:`q \approx 2\pi/d_{NN}` with :math:`d_{NN}` as the next</span>
<span class="sd">    neighbour distance between particles.</span>

<span class="sd">    :math:`b_i(q)` is a particle formfactor amplitude of the particles as e.g. q dependent Xray</span>
<span class="sd">    scattering amplitude or the formfactors in a cloud of different particles,</span>
<span class="sd">    but may also be constant as for neutron scattering atomic formfactors.</span>

<span class="sd">    Random displacements :math:`u_i` lead to :math:`r_i=r_i+u_i` and to the Debye-Waller factor for Bragg peaks</span>
<span class="sd">    and diffusive scattering at higher q. See :ref:`A nano cube build of different lattices` .</span>

<span class="sd">    The explicit orientational average can be simplified using the **Debye scattering equation** [4]_</span>

<span class="sd">     .. math::  I(Q)=\sum_i \sum_j b_i(q) b_j(q) \frac{\sin(qr_{ij})}{qr_{ij}}</span>
<span class="sd">                     =\sum_i b_i(q)^2 + 2\sum_i \sum_{j&gt;i} b_i(q) b_j(q) \frac{\sin(qr_{ij})}{qr_{ij}}</span>

<span class="sd">    Here no rms or ffpolydispersity are included. The calculation of :math:`beta` requires an additional calculation.</span>

<span class="sd">    The scattering of a cloud can represent the scattering of a *cluster of particles* with polydispersity</span>
<span class="sd">    and position distortion according to root mean square displacements (rms).</span>
<span class="sd">    Polydispersity and rms displacements are randomly changed within the orientational average to represent</span>
<span class="sd">    an ensemble average (opposite to the time average of a single cluster).</span>

<span class="sd">    **Examples**</span>
<span class="sd">     - See :py:func:`~.structurefactor.latticeStructureFactor` for nanocubes.</span>
<span class="sd">     - :ref:`A nano cube build of different lattices` .</span>
<span class="sd">     - The model :py:func:`~.formfactor.linearPearls` uses cloudscattering.</span>
<span class="sd">       Look into the source code as example how to create a complex model.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The example compares to the analytic solution for an ellipsoid then for a cube.</span>
<span class="sd">    For other shapes the grid may be better rotated away from the object symmetry or a random grid should be used.</span>
<span class="sd">    The example shows a good approximation with NN=20. Because of the grid peak at :math:`q=2\pi/d_{NN}`</span>
<span class="sd">    the grid scatterer distance :math:`d_{NN}` should be :math:`d_{NN} &lt; \frac{1}{3} 2\pi/q_{max}` .</span>

<span class="sd">    Inspecting :ref:`A nano cube build of different lattices` shows other possibilities building a grid.</span>
<span class="sd">    Also a pseudo random grid can be used :py:func:`~.structurefactor.pseudoRandomLattice` .</span>

<span class="sd">    ::</span>

<span class="sd">     # ellipsoid with grid build by mgrid</span>
<span class="sd">     import jscatter as js</span>
<span class="sd">     import numpy as np</span>
<span class="sd">     import matplotlib.pyplot as plt</span>
<span class="sd">     from mpl_toolkits.mplot3d import Axes3D</span>
<span class="sd">     # cubic grid points</span>
<span class="sd">     R=3;NN=20;relError=50</span>
<span class="sd">     grid= np.mgrid[-R:R:1j*NN, -R:R:1j*NN,-2*R:2*R:2j*NN].reshape(3,-1).T</span>
<span class="sd">     # points inside of sphere with radius R</span>
<span class="sd">     p=1;p2=1*2 # p defines a superball with 1-&gt;sphere p=inf cuboid ....</span>
<span class="sd">     inside=lambda xyz,R1,R2,R3:(np.abs(xyz[:,0])/R1)**p2+(np.abs(xyz[:,1])/R2)**p2+(np.abs(xyz[:,2])/R3)**p2&lt;=1</span>
<span class="sd">     insidegrid=grid[inside(grid,R,R,2*R)]</span>
<span class="sd">     q=np.r_[0:5:0.1]</span>
<span class="sd">     p=js.grace()</span>
<span class="sd">     p.title(&#39;compare form factors of an ellipsoid&#39;)</span>
<span class="sd">     ffe=js.ff.cloudScattering(q,insidegrid,relError=relError)</span>
<span class="sd">     p.plot(ffe,legend=&#39;cloud ff explicit&#39;)</span>
<span class="sd">     ffa=js.ff.ellipsoid(q,2*R,R)</span>
<span class="sd">     p.plot(ffa.X,ffa.Y/ffa.I0,li=1,sy=0,legend=&#39;analytic formula&#39;)</span>
<span class="sd">     p.legend()</span>
<span class="sd">     # show only each 20th point</span>
<span class="sd">     js.mpl.scatter3d(insidegrid[::10,:])</span>

<span class="sd">    ::</span>

<span class="sd">     # cube</span>
<span class="sd">     # grid points generated by cubic grid</span>
<span class="sd">     import jscatter as js</span>
<span class="sd">     import numpy as np</span>
<span class="sd">     q=np.r_[0.1:5:0.1]</span>
<span class="sd">     p=js.grace()</span>
<span class="sd">     R=3;N=10;relError=0.01  # random points on sphere</span>
<span class="sd">     grid= js.sf.scLattice(R/N,N)</span>
<span class="sd">     ffe=js.ff.cloudScattering(q,grid,relError=relError)</span>
<span class="sd">     p.plot(ffe,legend=&#39;cloud ff explicit 10&#39;)</span>
<span class="sd">     # each point has a cube around it including the border</span>
<span class="sd">     ffa=js.ff.cuboid(q,2*R+R/N)</span>
<span class="sd">     p.plot(ffa.X,ffa.Y/ffa.I0,li=1,sy=0,legend=&#39;analytic formula&#39;)</span>
<span class="sd">     p.yaxis(scale=&#39;l&#39;)</span>
<span class="sd">     p.title(&#39;compare form factors of an cube&#39;)</span>
<span class="sd">     p.legend(x=2,y=0.1)</span>


<span class="sd">    An objekt with **explicit given formfactor** for each gridpoint.</span>
<span class="sd">    ::</span>

<span class="sd">     import jscatter as js</span>
<span class="sd">     import numpy as np</span>
<span class="sd">     q = js.loglist(0.01, 7, 100)</span>
<span class="sd">     # 5 coreshell particles in line with polydispersity</span>
<span class="sd">     rod0 = np.zeros([5, 3])</span>
<span class="sd">     rod0[:, 1] = np.r_[0, 1, 2, 3, 4] * 4</span>
<span class="sd">     cs = js.ff.sphereCoreShell(q=q, Rc=1, Rs=2, bc=0.1, bs=1, solventSLD=0)</span>
<span class="sd">     csa = np.c_[cs.X,cs[2]].T</span>
<span class="sd">     ffe = js.ff.cloudScattering(q, rod0, formfactor=csa,relError=100,ffpolydispersity=0.1)</span>
<span class="sd">     p=js.grace()</span>
<span class="sd">     p.plot(ffe)</span>

<span class="sd">    Using cloudScattering as **fit model**.</span>

<span class="sd">    We have to define a model that parametrizes the building of the cloud that we get fit parameters.</span>
<span class="sd">    As example we use two overlapping spheres. The model can be used to fit some data.</span>
<span class="sd">    The build of the model is important as it describes how the overlap is treated e.g. as average.</span>

<span class="sd">    We have to consider some points:</span>
<span class="sd">     - It is important that the model is continuous in its parameters to avoid steps as</span>
<span class="sd">       any fit algorithm cannot handle this.</span>
<span class="sd">     - We have to limit some parameters that make giant grids.</span>
<span class="sd">       Fit algorithm make first a small step then a large one to estimate a good step size for parameter changes.</span>
<span class="sd">       If in the dumbbell example the radii R1 or R2 is increased to &gt;1000 then the grid size burst the RAM</span>
<span class="sd">       and we get a Memory Error. Use hard limits for the radii to a reasonable value as shown below (see setlimit).</span>
<span class="sd">     - The argument &quot;factor&quot; limits the initial step size. Reduce it (default 100 -&gt; [0.1..100]).</span>
<span class="sd">     - In the below example the first fit is fast but bad as we find a local minimum.</span>
<span class="sd">       A global fit algorithm takes quite long but finds the correct solution.</span>

<span class="sd">    ::</span>

<span class="sd">     import jscatter as js</span>
<span class="sd">     import numpy as np</span>
<span class="sd">     #</span>
<span class="sd">     #: test if distance from point on X axis</span>
<span class="sd">     isInside=lambda x,A,R:((x-np.r_[A,0,0])**2).sum(axis=1)**0.5&lt;R</span>
<span class="sd">     #: model</span>
<span class="sd">     def dumbbell(q,A,R1,b1,bgr=0,dx=0.3,relError=50):</span>
<span class="sd">         # D sphere distance</span>
<span class="sd">         # R1, R2 radii</span>
<span class="sd">         # b1,b2  scattering length</span>
<span class="sd">         # bgr background</span>
<span class="sd">         # dx grid distance not a fit parameter!!</span>
<span class="sd">         R2=R1</span>
<span class="sd">         b2=b1</span>
<span class="sd">         mR=max(R1,R2)</span>
<span class="sd">         # xyz coordinates</span>
<span class="sd">         grid=np.mgrid[-A/2-mR:A/2+mR:dx,-mR:mR:dx,-mR:mR:dx].reshape(3,-1).T</span>
<span class="sd">         insidegrid=grid[isInside(grid,-A/2.,R1) | isInside(grid,A/2.,R2)]</span>
<span class="sd">         # add blength column</span>
<span class="sd">         insidegrid=np.c_[insidegrid,insidegrid[:,0]*0]</span>
<span class="sd">         # set the corresponding blength; the order is important as here b2 overwrites b1</span>
<span class="sd">         insidegrid[isInside(insidegrid[:,:3],-A/2.,R1),3]=b1</span>
<span class="sd">         insidegrid[isInside(insidegrid[:,:3],A/2.,R2),3]=b2</span>
<span class="sd">         # and maybe a mix ; this depends on your model</span>
<span class="sd">         insidegrid[isInside(insidegrid[:,:3],-A/2.,R1) &amp; isInside(insidegrid[:,:3],A/2.,R2),3]=(b2+b1)/2.</span>
<span class="sd">         # calc the scattering</span>
<span class="sd">         result=js.ff.cloudScattering(q,insidegrid,relError=relError)</span>
<span class="sd">         result.Y=result.Y*result.I0+bgr</span>
<span class="sd">         # add attributes for later usage</span>
<span class="sd">         result.A=A</span>
<span class="sd">         result.R1=R1</span>
<span class="sd">         result.b1=b1</span>
<span class="sd">         result.dx=dx</span>
<span class="sd">         result.insidegrid=insidegrid</span>
<span class="sd">         return result</span>
<span class="sd">     #</span>
<span class="sd">     # test it</span>
<span class="sd">     q=np.r_[0.01:5:0.02]</span>
<span class="sd">     data=dumbbell(q,3,2,1)</span>

<span class="sd">     # show result configuration</span>
<span class="sd">     js.mpl.scatter3d(data.insidegrid[:,0],data.insidegrid[:,1],data.insidegrid[:,2])</span>
<span class="sd">     #</span>
<span class="sd">     # Fit your data like this.</span>
<span class="sd">     # It may be a good idea to use not the highest resolution in the beginning because of speed.</span>
<span class="sd">     # If you have a good set of starting parameters you can decrease dx.</span>
<span class="sd">     data2=data.prune(number=100)</span>
<span class="sd">     data2.makeErrPlot(yscale=&#39;l&#39;)</span>

<span class="sd">     data2=data.prune(number=100)</span>
<span class="sd">     data2.makeErrPlot(yscale=&#39;l&#39;)</span>
<span class="sd">     data2.setLimit(R1=[None,None,1,4],A=[None,None,1,10])</span>

<span class="sd">     # this results in a fast but bad fit result</span>
<span class="sd">     # a local minima is found but the basics is working.</span>
<span class="sd">     data2.fit(model=dumbbell,</span>
<span class="sd">                freepar={&#39;A&#39;:3,&#39;R1&#39;:2.4,&#39;b1&#39;:1},</span>
<span class="sd">                fixpar={&#39;dx&#39;:0.3,&#39;bgr&#39;:0},</span>
<span class="sd">                mapNames={&#39;q&#39;:&#39;X&#39;},factor=1)</span>

<span class="sd">     # To get a good result we need to find the global minimum by a different algorithm (&#39;differential evolution&#39;)</span>
<span class="sd">     # The limits are used as border to search in an limited area.</span>
<span class="sd">     # The fit takes about 3500 iterations (1000s on Ryzen 1600X 6 cores)</span>
<span class="sd">     data2.fit(model=dumbbell,method=&#39;differential_evolution&#39;,</span>
<span class="sd">                freepar={&#39;A&#39;:3,&#39;R1&#39;:2.4,&#39;b1&#39;:1},</span>
<span class="sd">                fixpar={&#39;dx&#39;:0.3,&#39;bgr&#39;:0},</span>
<span class="sd">                mapNames={&#39;q&#39;:&#39;X&#39;})</span>

<span class="sd">    Fit a sphere formfactor.</span>

<span class="sd">    The quality of the grid approximation (number of gridpoints) may</span>
<span class="sd">    improve the correct description of higher order minima.</span>
<span class="sd">    ::</span>

<span class="sd">     import numpy as np</span>
<span class="sd">     import jscatter as js</span>

<span class="sd">     # a function to discriminate what is inside of the sphere</span>
<span class="sd">     # basically a superball p2=2 is a sphere</span>
<span class="sd">     inside=lambda xyz,R1,p2:(np.abs(xyz[:,0]))**p2+(np.abs(xyz[:,1]))**p2+(np.abs(xyz[:,2]))**p2&lt;=R1**2</span>

<span class="sd">     def test(q,R,b,p2=2,relError=20):</span>
<span class="sd">         # make cubic grid with right size (increase NN for better approximation)</span>
<span class="sd">         NN=20</span>
<span class="sd">         grid= np.mgrid[-R:R:1j*NN, -R:R:1j*NN,-R:R:1j*NN].reshape(3,-1).T</span>
<span class="sd">         # cut the edges to get a sphere</span>
<span class="sd">         insidegrid=grid[inside(grid,R,p2)]</span>
<span class="sd">         # add scattering length for points</span>
<span class="sd">         # the average scattering length density is sum(b)/sphereVolume</span>
<span class="sd">         insidegrid=np.c_[insidegrid,insidegrid[:,0]*0]</span>
<span class="sd">         insidegrid[:,3]=b</span>
<span class="sd">         # calc formfactor (normalised) for a single sphere</span>
<span class="sd">         ffs=js.ff.cloudScattering(q,insidegrid,relError=relError)</span>
<span class="sd">         # the total scattering is sumblength**2</span>
<span class="sd">         ffs.Y*=ffs.sumblength**2</span>
<span class="sd">         # save radius and the grid for later</span>
<span class="sd">         ffs.R=R</span>
<span class="sd">         ffs.insidegrid=insidegrid</span>
<span class="sd">         return ffs</span>

<span class="sd">     ####main</span>
<span class="sd">     q=np.r_[0:3:0.01]</span>
<span class="sd">     sp=js.formfactor.sphere(q,3,1)</span>

<span class="sd">     sp.makeErrPlot(yscale=&#39;l&#39;)   # show intermediate results</span>
<span class="sd">     sp.setlimit(R=[0.3,10])      # set some reasonable limits for R</span>
<span class="sd">     sp.fit(model=test,</span>
<span class="sd">         freepar={&#39;b&#39;:6,&#39;R&#39;:2.1},</span>
<span class="sd">         fixpar={},</span>
<span class="sd">         mapNames={&#39;q&#39;:&#39;X&#39;})</span>

<span class="sd">     # show the resulting sphere grid</span>
<span class="sd">     resultgrid=sp.lastfit.insidegrid</span>
<span class="sd">     js.mpl.scatter3d(resultgrid[:,0],resultgrid[:,1],resultgrid[:,2])</span>

<span class="sd">    Here we compare explicit calculation with the Debye equation as the later gets quite slow for larger numbers.</span>
<span class="sd">    ::</span>

<span class="sd">     import jscatter as js</span>
<span class="sd">     import numpy as np</span>
<span class="sd">     R=6;NN=20</span>
<span class="sd">     q=np.r_[0:5:0.1]</span>
<span class="sd">     grid=js.formel.randomPointsInCube(10000)*R-R/2</span>
<span class="sd">     ffe=js.ff.cloudScattering(q,grid,relError=150)    # takes about  1.3 s on six core</span>
<span class="sd">     ffd=js.ff.cloudScattering(q,grid,relError=0)      # takes about 11.4 s on six core</span>
<span class="sd">     grid=js.formel.randomPointsInCube(500)*R-R/2</span>
<span class="sd">     ffe=js.ff.cloudScattering(q,grid,relError=150)    # takes about 132 ms on six core</span>
<span class="sd">     ffd=js.ff.cloudScattering(q,grid,relError=0)      # takes about  33 ms on six core</span>

<span class="sd">     p=js.grace()</span>
<span class="sd">     p.plot(ffe)</span>
<span class="sd">     p.plot(ffd)</span>
<span class="sd">     p.yaxis(scale=&#39;l&#39;)</span>


<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] M. Kotlarchyk and S.-H. Chen, J. Chem. Phys. 79, 2461 (1983).1</span>
<span class="sd">    .. [2] An improved method for calculating the contribution of solvent to</span>
<span class="sd">           the X-ray diffraction pattern of biological molecules</span>
<span class="sd">           Fraser R MacRae T Suzuki E IUCr Journal of Applied Crystallography 1978 vol: 11 (6) pp: 693-694</span>
<span class="sd">    .. [3] X-ray diffuse scattering by proteins in solution. Consideration of solvent influence</span>
<span class="sd">           B. A. Fedorov, O. B. Ptitsyn and L. A. Voronin</span>
<span class="sd">           J. Appl. Cryst. (1974). 7, 181-186 doi: 10.1107/S0021889874009137</span>
<span class="sd">    .. [4] Zerstreuung von Röntgenstrahlen</span>
<span class="sd">           Debye P. Annalen der Physik 1915 vol: 351 (6) pp: 809-823 DOI: 10.1002/andp.19153510606</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="c1"># last columns are scattering length and iff</span>
        <span class="n">blength</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">iff</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># index in formfactor</span>
        <span class="n">cloud</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="c1"># last column is scattering length</span>
        <span class="n">blength</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">cloud</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">blength</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">sumblength</span> <span class="o">=</span> <span class="n">blength</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">relError</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">relError</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">formfactor</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">formfactor</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">):</span>
            <span class="c1"># gaussian shape</span>
            <span class="n">formfactoramp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">q</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">V</span> <span class="o">**</span> <span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
            <span class="n">formfactor</span> <span class="o">=</span> <span class="s1">&#39;gaussian&#39;</span>
            <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">formfactor</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">):</span>
            <span class="c1"># sphere</span>
            <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.</span> <span class="o">*</span> <span class="n">V</span> <span class="o">/</span> <span class="mf">4.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span>
            <span class="n">formfactoramp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">_fa_sphere</span><span class="p">(</span><span class="n">q</span> <span class="o">*</span> <span class="n">R</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
            <span class="n">formfactor</span> <span class="o">=</span> <span class="s1">&#39;sphere&#39;</span>
            <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">formfactor</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">):</span>
            <span class="c1"># polymer coil showing Debye scattering</span>
            <span class="n">Rg</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.</span> <span class="o">*</span> <span class="n">V</span> <span class="o">/</span> <span class="mf">4.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span>
            <span class="n">formfactoramp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">_fa_coil</span><span class="p">(</span><span class="n">q</span> <span class="o">*</span> <span class="n">Rg</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
            <span class="n">formfactor</span> <span class="o">=</span> <span class="s1">&#39;polymer&#39;</span>
            <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">formfactor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">formfactoramp</span> <span class="o">=</span> <span class="n">formfactor</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">formfactoramp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">formfactor</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="n">formfactor</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">formfactor</span> <span class="o">=</span> <span class="s1">&#39;explicit&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># const form factor as default</span>
        <span class="n">formfactoramp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">q</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">formfactor</span> <span class="o">=</span> <span class="s1">&#39;constant&#39;</span>
        <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">relError</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Debye equation</span>
        <span class="c1"># no asymmetry factor beta, no rms, no ffpolydispersity</span>
        <span class="k">if</span> <span class="n">useFortran</span><span class="p">:</span>
            <span class="c1"># about 4 timesfaster than below python version on single core</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">fscatter</span><span class="o">.</span><span class="n">cloud</span><span class="o">.</span><span class="n">scattering_debye</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cloud</span><span class="p">,</span> <span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="p">,</span> <span class="n">ncpu</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">dA</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">sumblength</span> <span class="o">**</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># res=[_scattering_Debye(qx, cloud, blength, iff, formfactoramp) for qx in q]</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">parallel</span><span class="o">.</span><span class="n">doForList</span><span class="p">(</span><span class="n">_scattering_Debye</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span>
                                     <span class="n">r</span><span class="o">=</span><span class="n">cloud</span><span class="p">,</span> <span class="n">blength</span><span class="o">=</span><span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="o">=</span><span class="n">iff</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="o">=</span><span class="n">formfactoramp</span><span class="p">,</span>
                                     <span class="n">ncpu</span><span class="o">=</span><span class="n">ncpu</span><span class="p">,</span> <span class="n">loopover</span><span class="o">=</span><span class="s1">&#39;q&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">dA</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">res</span> <span class="o">/</span> <span class="n">sumblength</span> <span class="o">**</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">columnname</span> <span class="o">=</span> <span class="s1">&#39;q; Pq&#39;</span>
    <span class="k">elif</span> <span class="n">relError</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># explicit average</span>
        <span class="c1"># allows asymmetry factor beta, rms, ffpolydispersity</span>
        <span class="k">if</span> <span class="n">useFortran</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">parallel</span><span class="o">.</span><span class="n">doForList</span><span class="p">(</span><span class="n">_sphaverage_scattering</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span>
                                     <span class="n">r</span><span class="o">=</span><span class="n">cloud</span><span class="p">,</span> <span class="n">blength</span><span class="o">=</span><span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="o">=</span><span class="n">iff</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="o">=</span><span class="n">formfactoramp</span><span class="p">,</span> <span class="n">rms</span><span class="o">=</span><span class="n">rms</span><span class="p">,</span>
                                     <span class="n">ffpolydispersity</span><span class="o">=</span><span class="n">ffpolydispersity</span><span class="p">,</span>
                                     <span class="n">ncpu</span><span class="o">=</span><span class="n">ncpu</span><span class="p">,</span> <span class="n">relError</span><span class="o">=</span><span class="n">relError</span><span class="p">,</span> <span class="n">loopover</span><span class="o">=</span><span class="s1">&#39;q&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># in _scattering there is a choice to use pure python; the above instant fortran call is 20% faster</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">parallel</span><span class="o">.</span><span class="n">doForList</span><span class="p">(</span><span class="n">formel</span><span class="o">.</span><span class="n">sphereAverage</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">_scattering</span><span class="p">,</span>
                                     <span class="n">r</span><span class="o">=</span><span class="n">cloud</span><span class="p">,</span> <span class="n">blength</span><span class="o">=</span><span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="o">=</span><span class="n">iff</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="o">=</span><span class="n">formfactoramp</span><span class="p">,</span> <span class="n">rms</span><span class="o">=</span><span class="n">rms</span><span class="p">,</span>
                                     <span class="n">ffpolydispersity</span><span class="o">=</span><span class="n">ffpolydispersity</span><span class="p">,</span>
                                     <span class="n">ncpu</span><span class="o">=</span><span class="n">ncpu</span><span class="p">,</span> <span class="n">relError</span><span class="o">=</span><span class="n">relError</span><span class="p">,</span> <span class="n">loopover</span><span class="o">=</span><span class="s1">&#39;q&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># the third row is F(Q)</span>
        <span class="c1"># asymmetry factor beta according to Chen  beta=|&lt;F(Q)&gt;|²/&lt;|F(Q)|²&gt;</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span> <span class="o">/</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">sumblength</span> <span class="o">**</span> <span class="mi">2</span>  <span class="c1"># normalisation</span>
        <span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">sumblength</span>       <span class="c1"># normalisation</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">dA</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">beta</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">columnname</span> <span class="o">=</span> <span class="s1">&#39;q; Pq; beta; fa&#39;</span>

    <span class="n">result</span><span class="o">.</span><span class="n">sumblength</span> <span class="o">=</span> <span class="n">sumblength</span>
    <span class="n">result</span><span class="o">.</span><span class="n">I0</span> <span class="o">=</span> <span class="n">sumblength</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">result</span><span class="o">.</span><span class="n">formfactoramplitude_q</span> <span class="o">=</span> <span class="n">formfactoramp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">result</span><span class="o">.</span><span class="n">formfactoramplitude</span> <span class="o">=</span> <span class="n">formfactoramp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">result</span><span class="o">.</span><span class="n">formfactor</span> <span class="o">=</span> <span class="n">formfactor</span>
    <span class="n">result</span><span class="o">.</span><span class="n">rms</span> <span class="o">=</span> <span class="n">rms</span>
    <span class="n">result</span><span class="o">.</span><span class="n">ffpolydispersity</span> <span class="o">=</span> <span class="n">ffpolydispersity</span>
    <span class="n">result</span><span class="o">.</span><span class="n">setColumnIndex</span><span class="p">(</span><span class="n">iey</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="n">result</span><span class="o">.</span><span class="n">modelname</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span>
    <span class="k">return</span> <span class="n">result</span></div>


<span class="k">def</span> <span class="nf">_coneAverage</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">qxzw</span><span class="p">,</span> <span class="n">qrpt</span><span class="p">,</span> <span class="n">qfib</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="p">,</span> <span class="n">rms</span><span class="p">):</span>
    <span class="n">q</span><span class="p">,</span> <span class="n">ilist</span> <span class="o">=</span> <span class="n">qlist</span>  <span class="c1"># ilist is index in qxzw of the qxzw with same q value</span>

    <span class="c1"># do the average for all in ilist</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">pi_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">useFortran</span><span class="p">:</span>
        <span class="n">qfib</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># cone around [0,0,1] direction; average_ffqxyz needs points on uni sphere</span>
        <span class="n">fibpoints</span> <span class="o">=</span> <span class="n">formel</span><span class="o">.</span><span class="n">rphitheta2xyz</span><span class="p">(</span><span class="n">qfib</span><span class="p">)</span>  <span class="c1"># cartesian coordinates of fibonacci lattice with radius q</span>
        <span class="k">for</span> <span class="n">il</span> <span class="ow">in</span> <span class="n">ilist</span><span class="p">:</span>
            <span class="c1"># get angles</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">qrpt</span><span class="p">[</span><span class="n">il</span><span class="p">]</span>
            <span class="c1"># rotate fibpoints to angles</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">formel</span><span class="o">.</span><span class="n">rotationMatrix</span><span class="p">(</span><span class="n">formel</span><span class="o">.</span><span class="n">rphitheta2xyz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span> <span class="o">-</span> <span class="n">pi_2</span><span class="p">,</span> <span class="n">pi_2</span><span class="p">]),</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">Rfibpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,jk-&gt;ki&#39;</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">fibpoints</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="c1"># take mean of rotated fibpoints</span>
            <span class="n">res</span><span class="p">[</span><span class="n">il</span><span class="p">]</span> <span class="o">=</span> <span class="n">fscatter</span><span class="o">.</span><span class="n">cloud</span><span class="o">.</span><span class="n">average_ffqxyz</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="p">,</span> <span class="n">rms</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Rfibpoints</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">formfactoramp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">amp</span><span class="p">)</span> <span class="k">for</span> <span class="n">amp</span> <span class="ow">in</span> <span class="n">formfactoramp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="n">blength</span> <span class="o">*</span> <span class="n">fa</span><span class="p">[</span><span class="n">iff</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">qfib</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span>  <span class="c1"># cone points around [0,0,1] direction</span>
        <span class="n">fibpoints</span> <span class="o">=</span> <span class="n">formel</span><span class="o">.</span><span class="n">rphitheta2xyz</span><span class="p">(</span><span class="n">qfib</span><span class="p">)</span>  <span class="c1"># cartesian coordinates of fibonacci lattice with radius q</span>
        <span class="k">for</span> <span class="n">il</span> <span class="ow">in</span> <span class="n">ilist</span><span class="p">:</span>
            <span class="c1"># get angles</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">qrpt</span><span class="p">[</span><span class="n">il</span><span class="p">]</span>
            <span class="c1"># rotate fibpoints to angles</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">formel</span><span class="o">.</span><span class="n">rotationMatrix</span><span class="p">(</span><span class="n">formel</span><span class="o">.</span><span class="n">rphitheta2xyz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span> <span class="o">-</span> <span class="n">pi_2</span><span class="p">,</span> <span class="n">pi_2</span><span class="p">]),</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">Rfibpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,jk-&gt;ki&#39;</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">fibpoints</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="c1"># take mean of rotated fibpoints</span>
            <span class="n">res</span><span class="p">[</span><span class="n">il</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">_sqx</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">fa</span><span class="p">,</span> <span class="n">rms</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">Rfibpoints</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">_sqx</span><span class="p">(</span><span class="n">qx</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">fa</span><span class="p">,</span> <span class="n">rms</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    coherent scattering of equal objects at positions r in direction point on</span>
<span class="sd">    sphere with length (radius) q</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    qx :  array 3 x 1</span>
<span class="sd">        point on unit sphere within oriented cone</span>
<span class="sd">    r : array  N x 3</span>
<span class="sd">        vector of objekt positions</span>
<span class="sd">    fa : float</span>
<span class="sd">        blength*formfactor(q)</span>
<span class="sd">    rms : float</span>
<span class="sd">        &lt; random displacements &gt;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    F(Q)*F(Q).conj()</span>

<span class="sd">    pure numpy way</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rms</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">rms</span>
    <span class="n">iqr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,ji&#39;</span><span class="p">,</span> <span class="n">qx</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span>
    <span class="n">beiqrsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,i&#39;</span><span class="p">,</span> <span class="n">fa</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">iqr</span><span class="p">))</span>
    <span class="n">Sq</span> <span class="o">=</span> <span class="n">beiqrsum</span> <span class="o">*</span> <span class="n">beiqrsum</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">Sq</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">beiqrsum</span><span class="o">.</span><span class="n">real</span>


<div class="viewcode-block" id="orientedCloudScattering"><a class="viewcode-back" href="../../formfactor.html#jscatter.cloudscattering.orientedCloudScattering">[docs]</a><span class="k">def</span> <span class="nf">orientedCloudScattering</span><span class="p">(</span><span class="n">qxzw</span><span class="p">,</span> <span class="n">cloud</span><span class="p">,</span> <span class="n">rms</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">coneangle</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">nCone</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">V</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">formfactor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ncpu</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    2D scattering of an oriented cloud of scatterers with equal or variable scattering length. Using multiprocessing.</span>

<span class="sd">    Cloud can represent an object described by a cloud of isotropic scatterers with orientation averaged in a cone.</span>
<span class="sd">    Scattering amplitudes may be constant, sphere scattering amplitude, Gaussian scattering amplitude</span>
<span class="sd">    or explicitly given form factor. Remember that the atomic bond length are on the order 0.1-0.2 nm</span>
<span class="sd">    and one expects Bragg peaks.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    qxzw : array, ndim= Nx3</span>
<span class="sd">         3D wavevectors in 1/nm</span>
<span class="sd">         If 2D the 3rd dim is set to zero. Wavevectors may represent a line, a plane or any other 3D distribution in</span>
<span class="sd">         reciprocal space.</span>
<span class="sd">    cloud : array Nx3, Nx4, Nx5</span>
<span class="sd">        - Center of mass positions (in nm) of the N scatterers in the cloud.</span>
<span class="sd">        - If given cloud[3] is the scattering length :math:`b` at positions cloud[:3], otherwise :math:`b=1`.</span>
<span class="sd">        - If given cloud[4] is the column index in formfactor for a specific scatterer.</span>
<span class="sd">    coneangle : float</span>
<span class="sd">        Cone angle in units degrees.</span>
<span class="sd">    rms : float, default=0</span>
<span class="sd">        Root mean square displacement :math:`\langleu^2\rangle^{0.5} of the positions in cloud as random</span>
<span class="sd">        displacements in nm. The displacement u is randomly chosen for each orientation in cone.</span>
<span class="sd">        rms can be used to simulate a Debye-Waller factor. Larger nCone is advised yield reasonable average.</span>
<span class="sd">    nCone : int</span>
<span class="sd">        Cone average as average over nCone Fibonacci lattice points in cone.</span>
<span class="sd">    formfactor : None,&#39;gauss&#39;,&#39;sphere&#39;,&#39;cube&#39;</span>
<span class="sd">        Scattering amplitudes :math:`F_a(q)` of scatterers are described as:</span>
<span class="sd">         - None    : const scattering amplitude.</span>
<span class="sd">         - &#39;sphere&#39;: Sphere scattering amplitude according to [3]_.</span>
<span class="sd">                     Parameter V needed to determine :math:`R`.</span>
<span class="sd">                     The sphere radius is :math:`R=(\frac{3V}{4\pi})^{1/3}`.</span>
<span class="sd">                     The scattering length per particle is :math:`b_i = V* contrast`</span>
<span class="sd">         - &#39;gauss&#39; : Gaussian function  :math:`b_i(q)=b V exp(-\pi V^{2/3}q^2)` according to [2]_.</span>
<span class="sd">                     The Gaussian shows no artificial minima compared to spheres.</span>
<span class="sd">                     The scattering length per particle is :math:`b_i = V* contrast`</span>
<span class="sd">         - &#39;coil&#39; :  Polymer coil (ideal Gaussian chain) showing scattering according to Debye function.</span>
<span class="sd">                     Parameter V needed to determine :math:`R_g = (\frac{3V}{4\pi})^{1/3}`.</span>
<span class="sd">                     The scattering length is :math:`b_i = Nb_{monomer}` with monomer number :math:`N`</span>
<span class="sd">         - Explicit isotropic :math:`F_a(q)` as array with [q,fa1(q),fa2(q),fa3(q),....].</span>
<span class="sd">            - If multiple fai are given the index i for a cloud point needs to be given in cloud[4]</span>
<span class="sd">            - The normalized scattering amplitude fa for each cloud point is calculated as fa=fai/fai[0].</span>
<span class="sd">              Missing values are linear interpolated (np.interp), q values outside interval are mapped to qmin or qmax.</span>
<span class="sd">            - Explicit formfactors are assumed to be isotropic.</span>
<span class="sd">            - If the scattering amplitude is not known :math:`F_a(q) \approx F^{1/2}(q)`</span>
<span class="sd">              might be used as approximation for low Q.</span>
<span class="sd">    V : float, default=None</span>
<span class="sd">        Volume of the scatterers to determine scattering amplitude (see formfactor).</span>
<span class="sd">        Only needed for formfactor &#39;sphere&#39; and &#39;gauss&#39;.</span>
<span class="sd">    ncpu : int, default 0</span>
<span class="sd">        Number of cpus used in the pool for multiprocessing.</span>
<span class="sd">         - not given or 0 : all cpus are used</span>
<span class="sd">         - int&gt;0          : min(ncpu, mp.cpu_count)</span>
<span class="sd">         - int&lt;0          : ncpu not to use</span>
<span class="sd">         - 1              : single core usage for testing or comparing speed to Debye</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dataArray</span>
<span class="sd">        Columns [qx, qz, qw, Sq]</span>
<span class="sd">         - The forward scattering is Pq(q=0)= sumblength**2</span>
<span class="sd">         - .sumblength : Sum of blength with sumblength**2</span>
<span class="sd">         - .formfactoramplitude : formfactoramplitude of cloudpoints according to type for all q values.</span>
<span class="sd">         - .formfactoramplitude_q :corresponding q values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    How to use orientedCloudScattering for fitting see last Example in cloudScattering.</span>

<span class="sd">    Two points along y result in pattern independent of x but cos**2 for z</span>
<span class="sd">    with larger coneangle Ix becomes qx dependent. ::</span>

<span class="sd">     import jscatter as js</span>
<span class="sd">     import numpy as np</span>
<span class="sd">     rod0=np.zeros([2,3])</span>
<span class="sd">     rod0[:,1]=np.r_[0,np.pi]</span>
<span class="sd">     qxzw=np.mgrid[-6:6:50j, -6:6:50j].reshape(2,-1).T</span>
<span class="sd">     ffe=js.ff.orientedCloudScattering(qxzw,rod0,coneangle=5,nCone=10,rms=0)</span>
<span class="sd">     fig=js.mpl.surface(ffe.X,ffe.Z,ffe.Y)</span>
<span class="sd">     fig.axes[0].set_title(r&#39;cos**2 for Z and slow decay for X due to 5 degree cone&#39;)</span>
<span class="sd">     fig.show()</span>
<span class="sd">     # noise in positions</span>
<span class="sd">     ffe=js.ff.orientedCloudScattering(qxzw,rod0,coneangle=5,nCone=100,rms=0.1)</span>
<span class="sd">     fig=js.mpl.surface(ffe.X,ffe.Z,ffe.Y)</span>
<span class="sd">     fig.axes[0].set_title(&#39;cos**2 for Y and slow decay for X with position noise&#39;)</span>
<span class="sd">     fig.show()</span>


<span class="sd">    Two points along z result in symmetric pattern around zero</span>
<span class="sd">    symmetry reflects fibonacci lattice -&gt; increase nCone ::</span>

<span class="sd">     rod0=np.zeros([2,3])</span>
<span class="sd">     rod0[:,2]=np.r_[0,np.pi]</span>
<span class="sd">     ffe=js.ff.orientedCloudScattering(qxzw,rod0,coneangle=45,nCone=10,rms=0.005)</span>
<span class="sd">     fig2=js.mpl.surface(ffe.X,ffe.Z,ffe.Y)</span>
<span class="sd">     fig2.axes[0].set_title(&#39;symmetric because of orientation along z; \n nCone needs to be larger for large cones&#39;)</span>
<span class="sd">     fig2.show()</span>


<span class="sd">    5 spheres in line with small position distortion ::</span>

<span class="sd">     rod0 = np.zeros([5, 3])</span>
<span class="sd">     rod0[:, 1] = np.r_[0, 1, 2, 3, 4] * 3</span>
<span class="sd">     qxzw = np.mgrid[-6:6:50j, -6:6:50j].reshape(2, -1).T</span>
<span class="sd">     ffe = js.ff.orientedCloudScattering(qxzw,rod0,formfactor=&#39;sphere&#39;,V=4/3.*np.pi*2**3,coneangle=20,nCone=30,rms=0.02)</span>
<span class="sd">     fig4 = js.mpl.surface(ffe.X, ffe.Z, np.log10(ffe.Y), colorMap=&#39;gnuplot&#39;)</span>
<span class="sd">     fig4.axes[0].set_title(&#39;5 spheres with R=2 along Z with noise (rms=0.02)&#39;)</span>
<span class="sd">     fig4.show()</span>


<span class="sd">    Solution of oriented particle-composite of 3 touching core shell particles with small position distortion.</span>
<span class="sd">    Here we add a isotropic Percus-Yevick structure factor as effective composite interaction</span>
<span class="sd">    between particle composites. ::</span>

<span class="sd">     N=6    # number of particles</span>
<span class="sd">     Rc=2   # core radius</span>
<span class="sd">     Rs=6   # outer shell radius</span>
<span class="sd">     d=Rs*2 # distance of particles</span>
<span class="sd">     volumefraction=0.10  # single particles</span>
<span class="sd">     rms=1.5</span>
<span class="sd">     # position composite particles along X axis</span>
<span class="sd">     rod0 = np.zeros([N, 3])</span>
<span class="sd">     rod0[:, 0] = np.r_[0:N] * d  # positions</span>
<span class="sd">     # q grid</span>
<span class="sd">     qxzw = np.mgrid[-2:2:150j, -2:2:150j].reshape(2, -1).T</span>
<span class="sd">     # core shell formfactor for particles and use interpolation</span>
<span class="sd">     q = js.loglist(0.01, 7, 100)</span>
<span class="sd">     cs = js.ff.sphereCoreShell(q=q, Rc=Rc, Rs=Rs, bc=-0.1, bs=1, solventSLD=0)</span>
<span class="sd">     csa = np.c_[cs.X,cs[2]].T</span>
<span class="sd">     # oriented composite scattering</span>
<span class="sd">     ffe = js.ff.orientedCloudScattering(qxzw, rod0, formfactor=csa, coneangle=5, nCone=100, rms=rms)</span>
<span class="sd">     fig4a = js.mpl.contourImage(ffe.X, ffe.Z, ffe.Y, colorMap=&#39;gnuplot&#39;,scale=&#39;log&#39;)</span>
<span class="sd">     fig4a.axes[0].set_title(&#39;3 core shell particles with R=2 along X with noise&#39;)</span>

<span class="sd">     # add structure factor according to radial q component</span>
<span class="sd">     sf=js.sf.PercusYevick(q, Rs*N/2, eta=volumefraction*N)  # approximate higher radius</span>
<span class="sd">     qradial=np.linalg.norm(ffe[:3],axis=0)</span>
<span class="sd">     ffe.Y=ffe.Y*sf.interp(qradial)</span>
<span class="sd">     fig4b = js.mpl.contourImage(ffe.X, ffe.Z, ffe.Y, colorMap=&#39;gnuplot&#39;,scale=&#39;log&#39;)</span>
<span class="sd">     fig4b.axes[0].set_title(&#39;3 core shell particles with noise and interparticle interaction &#39;)</span>
<span class="sd">     #fig4b.savefig(js.examples.imagepath+&#39;/orientedCloudScattering.jpg&#39;)</span>

<span class="sd">    .. image:: ../../examples/images/orientedCloudScattering.jpg</span>
<span class="sd">     :width: 70 %</span>
<span class="sd">     :align: center</span>
<span class="sd">     :alt: orientedCloudScattering</span>



<span class="sd">    Make a slice for an angular region but with higher resolution to see the additional peaks due to alignment</span>
<span class="sd">    ::</span>

<span class="sd">     # rod0 will be position of 5 points in a row</span>
<span class="sd">     rod0 = np.zeros([5, 3])</span>
<span class="sd">     rod0[:, 1] = np.r_[0, 1, 2, 3, 4] * 3</span>

<span class="sd">     qxzw = np.mgrid[-4:4:150j, -4:4:150j].reshape(2, -1).T    # xz plane grid</span>
<span class="sd">     # only as demo : extract q from qxzw</span>
<span class="sd">     qxzw = np.c_[qxzw, np.zeros_like(qxzw[:, 0])]              # add y=0 component</span>
<span class="sd">     qrpt = js.formel.xyz2rphitheta(qxzw)                     # spherical coordinates</span>
<span class="sd">     q = np.unique(sorted(qrpt[:, 0]))</span>

<span class="sd">     # or use interpolation; cs will be our formfactor</span>
<span class="sd">     q = js.loglist(0.01, 7, 100)</span>
<span class="sd">     csa = js.ff.sphereCoreShell(q=q, Rc=1, Rs=2, bc=0.1, bs=1, solventSLD=0)[[0,2]]</span>

<span class="sd">     # calc scattering in plane qxzw</span>
<span class="sd">     ffe = js.ff.orientedCloudScattering(qxzw, rod0, formfactor=csa, coneangle=20, nCone=100, rms=0.05)</span>

<span class="sd">     # show it in surface plot</span>
<span class="sd">     fig4 = js.mpl.surface(ffe.X, ffe.Z, np.log10(ffe.Y), colorMap=&#39;gnuplot&#39;)</span>
<span class="sd">     fig4.axes[0].set_title(&#39;5 core shell particles with R=2 along Z with noise (rms=0.05)&#39;)</span>
<span class="sd">     fig4.show()</span>

<span class="sd">     # We do an explicit radial average</span>
<span class="sd">     # transform X,Z to spherical coordinates</span>
<span class="sd">     qphi=js.formel.xyz2rphitheta([ffe.X,ffe.Z,np.zeros_like(ffe.X)],transpose=True )[:,:2]</span>
<span class="sd">     # add qphi or use later rp[1] for selection</span>
<span class="sd">     ffb=ffe.addColumn(2,qphi.T)</span>
<span class="sd">     # select a portion of the phi angles</span>
<span class="sd">     phi=np.pi/2</span>
<span class="sd">     dphi=0.2</span>
<span class="sd">     ffn=ffb[:,(ffb[-1]&lt;phi+dphi)&amp;(ffb[-1]&gt;phi-dphi)]</span>
<span class="sd">     ffn.isort(-2)    # sort along radial q</span>
<span class="sd">     p=js.grace()</span>
<span class="sd">     p.plot(ffn[-2],ffn.Y,le=&#39;oriented spheres form factor&#39;)</span>
<span class="sd">     # compare to coreshell formfactor scaled</span>
<span class="sd">     p.plot(cs.X,cs.Y/cs.Y[0]*25,li=1,le=&#39;coreshell form factor&#39;)</span>
<span class="sd">     p.yaxis(label=&#39;F(Q,phi=90°+-11°)&#39;, scale=&#39;log&#39;)</span>
<span class="sd">     p.title(&#39;5 aligned core shell particle with additional interferences&#39;,size=1.)</span>
<span class="sd">     p.subtitle(&#39; due to sphere alignment dependent on observation angle&#39;)</span>

<span class="sd">     # 2: direct way with 2D q in xz plane</span>
<span class="sd">     rod0 = np.zeros([5, 3])</span>
<span class="sd">     rod0[:, 1] = np.r_[0, 1, 2, 3, 4] * 3</span>
<span class="sd">     x=np.r_[0.0:6:0.05]</span>
<span class="sd">     qxzw = np.c_[x, x*0,x*0]</span>
<span class="sd">     for alpha in np.r_[0:91:30]:</span>
<span class="sd">         R=js.formel.rotationMatrix(np.r_[0,0,1],np.deg2rad(alpha)) # rotate around Z axis</span>
<span class="sd">         qa=np.dot(R,qxzw.T).T[:,:2]</span>
<span class="sd">         ffe = js.ff.orientedCloudScattering(qa, rod0, formfactor=csa, coneangle=20, nCone=100, rms=0.05)</span>
<span class="sd">         p.plot(x,ffe.Y,li=[1,2,-1],sy=0,le=&#39;alpha=%g&#39; %alpha)</span>
<span class="sd">     p.xaxis(label=r&#39;Q / nm\S-1&#39;)</span>
<span class="sd">     p.legend()</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] M. Kotlarchyk and S.-H. Chen, J. Chem. Phys. 79, 2461 (1983).1</span>
<span class="sd">    .. [2] An improved method for calculating the contribution of solvent to</span>
<span class="sd">           the X-ray diffraction pattern of biological molecules</span>
<span class="sd">           Fraser R MacRae T Suzuki E IUCr Journal of Applied Crystallography 1978 vol: 11 (6) pp: 693-694</span>
<span class="sd">    .. [3] X-ray diffuse scattering by proteins in solution. Consideration of solvent influence</span>
<span class="sd">           B. A. Fedorov, O. B. Ptitsyn and L. A. Voronin J. Appl. Cryst. (1974). 7, 181-186</span>
<span class="sd">           doi: 10.1107/S0021889874009137</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nCone</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">nCone</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">qxzw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># make 3D q with qz=0</span>
        <span class="n">qxzw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">qxzw</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">qxzw</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])]</span>

    <span class="k">if</span> <span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="c1"># last columns are scattering length and iff</span>
        <span class="n">blength</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">iff</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># index in formfactor</span>
        <span class="n">cloud</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="c1"># last column is scattering length</span>
        <span class="n">blength</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">cloud</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">blength</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">sumblength</span> <span class="o">=</span> <span class="n">blength</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># cone to average  which is around Z direction = [0,0,1]xyz = [1,0,0]rpt</span>
    <span class="n">qfib</span> <span class="o">=</span> <span class="n">formel</span><span class="o">.</span><span class="n">fibonacciLatticePointsOnSphere</span><span class="p">(</span><span class="n">nCone</span><span class="p">)</span>
    <span class="n">qfib</span> <span class="o">=</span> <span class="n">qfib</span><span class="p">[</span><span class="n">qfib</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># select half sphere</span>
    <span class="n">qfib</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="n">coneangle</span> <span class="o">/</span> <span class="mf">90.</span><span class="p">)</span>  <span class="c1"># shrink to cone</span>

    <span class="c1"># generate reduced q list for formfactors</span>
    <span class="c1"># transform to spherical coordinates and make selective qlist</span>
    <span class="n">qrpt</span> <span class="o">=</span> <span class="n">formel</span><span class="o">.</span><span class="n">xyz2rphitheta</span><span class="p">(</span><span class="n">qxzw</span><span class="p">)</span>
    <span class="n">qround</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">qrpt</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">qred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">qround</span><span class="p">)</span>  <span class="c1"># reduced q list list to 10**-3 precision</span>
    <span class="n">qlist</span> <span class="o">=</span> <span class="p">[(</span><span class="n">qi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">qround</span> <span class="o">==</span> <span class="n">qi</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">qi</span> <span class="ow">in</span> <span class="n">qred</span><span class="p">]</span>  <span class="c1"># list of q with original Q indices</span>

    <span class="c1"># define formfactor for qround</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">formfactor</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">formfactor</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">):</span>
            <span class="c1"># gaussian shape</span>
            <span class="n">formfactoramp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">qred</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">qred</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">V</span> <span class="o">**</span> <span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
            <span class="n">formfactor</span> <span class="o">=</span> <span class="s1">&#39;gaussian&#39;</span>
            <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">formfactor</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">):</span>
            <span class="c1"># sphere</span>
            <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.</span> <span class="o">*</span> <span class="n">V</span> <span class="o">/</span> <span class="mf">4.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span>
            <span class="n">formfactoramp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">qred</span><span class="p">,</span> <span class="n">_fa_sphere</span><span class="p">(</span><span class="n">qred</span> <span class="o">*</span> <span class="n">R</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
            <span class="n">formfactor</span> <span class="o">=</span> <span class="s1">&#39;sphere&#39;</span>
            <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">formfactor</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">):</span>
            <span class="c1"># polymer coil showing Debye scattering</span>
            <span class="n">Rg</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.</span> <span class="o">*</span> <span class="n">V</span> <span class="o">/</span> <span class="mf">4.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span>
            <span class="n">formfactoramp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">qred</span><span class="p">,</span> <span class="n">_fa_coil</span><span class="p">(</span><span class="n">qred</span> <span class="o">*</span> <span class="n">Rg</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
            <span class="n">formfactor</span> <span class="o">=</span> <span class="s1">&#39;polymer&#39;</span>
            <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">formfactor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">formfactoramp</span> <span class="o">=</span> <span class="n">formfactor</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">formfactoramp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">formfactor</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="n">formfactor</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">formfactor</span> <span class="o">=</span> <span class="s1">&#39;explicit&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># const form factor as default</span>
        <span class="n">formfactoramp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">qred</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">qred</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">formfactor</span> <span class="o">=</span> <span class="s1">&#39;constant&#39;</span>
        <span class="n">iff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># do in parallel for all q rings</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">parallel</span><span class="o">.</span><span class="n">doForList</span><span class="p">(</span><span class="n">_coneAverage</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span>
                             <span class="n">qxzw</span><span class="o">=</span><span class="n">qxzw</span><span class="p">,</span> <span class="n">qrpt</span><span class="o">=</span><span class="n">qrpt</span><span class="p">,</span> <span class="n">qfib</span><span class="o">=</span><span class="n">qfib</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">cloud</span><span class="p">,</span> <span class="n">blength</span><span class="o">=</span><span class="n">blength</span><span class="p">,</span> <span class="n">iff</span><span class="o">=</span><span class="n">iff</span><span class="p">,</span>
                             <span class="n">formfactoramp</span><span class="o">=</span><span class="n">formfactoramp</span><span class="p">,</span> <span class="n">rms</span><span class="o">=</span><span class="n">rms</span><span class="p">,</span>
                             <span class="n">ncpu</span><span class="o">=</span><span class="n">ncpu</span><span class="p">,</span> <span class="n">loopover</span><span class="o">=</span><span class="s1">&#39;qlist&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># distribute Sxy according to saved indices from qlist</span>
    <span class="n">Sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">qxzw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">res1</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">Sxy</span> <span class="ow">in</span> <span class="n">res1</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">Sq</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sxy</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">dA</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">qxzw</span><span class="p">,</span> <span class="n">Sq</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">sumblength</span> <span class="o">=</span> <span class="n">sumblength</span>
    <span class="n">result</span><span class="o">.</span><span class="n">formfactoramplitude_q</span> <span class="o">=</span> <span class="n">formfactoramp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">result</span><span class="o">.</span><span class="n">formfactoramplitude</span> <span class="o">=</span> <span class="n">formfactoramp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">result</span><span class="o">.</span><span class="n">formfactortype</span> <span class="o">=</span> <span class="n">formfactor</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
        <span class="n">result</span><span class="o">.</span><span class="n">Volume</span> <span class="o">=</span> <span class="n">V</span>
    <span class="n">result</span><span class="o">.</span><span class="n">setColumnIndex</span><span class="p">(</span><span class="n">ix</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">iy</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">iz</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">iw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">iey</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">columnname</span> <span class="o">=</span> <span class="s1">&#39;qx; qz; qw; Sq; fa&#39;</span>

    <span class="n">result</span><span class="o">.</span><span class="n">modelname</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span>
    <span class="k">return</span> <span class="n">result</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/Jscatter1.gif" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../BeginnersGuide.html">1. Beginners Guide / Help</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dataArray.html">2. dataArray</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dataList.html">3. dataList</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../formel.html">4. formel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sas.html">5. smallanglescattering (sas)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../formfactor.html">6. formfactor (ff)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../structurefactor.html">7. structurefactor (sf)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dynamic.html">8. dynamic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dls.html">9. dls</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parallel.html">10. parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../GracePlot.html">11. Plotting in XmGrace</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mpl.html">12. mpl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">13. Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Extending.html">14. Extending/Contributing/Fortran</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tips.html">15. Tips</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Remarks.html">16. Intention and Remarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Installation.html">17. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../citing.html">18. Citing Jscatter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">19. Changelog</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Jscatter 1.2.7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">jscatter.cloudscattering</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2015-19, Ralf Biehl.
      Last updated on Sep 15, 2020.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>