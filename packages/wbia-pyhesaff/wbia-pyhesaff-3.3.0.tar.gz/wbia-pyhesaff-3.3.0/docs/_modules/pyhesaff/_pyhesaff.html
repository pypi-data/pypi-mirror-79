
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pyhesaff._pyhesaff &#8212; wbia-pyhesaff 3.1.0 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pyhesaff._pyhesaff</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The python hessian affine keypoint module</span>

<span class="sd">Command Line:</span>
<span class="sd">    python -m pyhesaff detect_feats --show --siftPower=0.5 --maxBinValue=-1</span>
<span class="sd">    python -m pyhesaff detect_feats --show</span>
<span class="sd">    python -m pyhesaff detect_feats --show --siftPower=0.5,</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">unicode_literals</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">zip</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">range</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="k">import</span> <span class="n">realpath</span><span class="p">,</span> <span class="n">dirname</span>
<span class="kn">import</span> <span class="nn">ctypes</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">ubelt</span> <span class="k">as</span> <span class="nn">ub</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pyhesaff</span> <span class="k">import</span> <span class="n">ctypes_interface</span>
<span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">ctypes_interface</span>

<span class="c1"># ============================</span>
<span class="c1"># hesaff ctypes interface</span>
<span class="c1"># ============================</span>

<span class="c1"># numpy dtypes</span>
<span class="n">kpts_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
<span class="n">vecs_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span>
<span class="n">img_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span>
<span class="n">img32_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
<span class="c1"># scalar ctypes</span>
<span class="n">obj_t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">c_void_p</span>
<span class="n">str_t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">c_char_p</span>
<span class="c1"># if True or six.PY2:  # HACK ALWAYS ON</span>
<span class="n">int_t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">c_int</span>
<span class="c1"># else:</span>
<span class="c1">#    raise NotImplementedError(&#39;PY3&#39;)</span>
<span class="c1"># if six.PY3:</span>
<span class="c1">#    int_t     = C.c_long</span>
<span class="n">bool_t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">c_bool</span>
<span class="n">float_t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">c_float</span>
<span class="c1"># byte_t    = C.c_char</span>
<span class="c1"># array ctypes</span>
<span class="n">FLAGS_RW</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="s1">&#39;aligned, c_contiguous, writeable&#39;</span><span class="p">)</span>
<span class="n">FLAGS_RO</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="s1">&#39;aligned, c_contiguous&#39;</span><span class="p">)</span>
<span class="c1"># FLAGS_RW = &#39;aligned, writeable&#39;</span>
<span class="n">kpts_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">kpts_dtype</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">FLAGS_RW</span><span class="p">)</span>
<span class="n">vecs_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">vecs_dtype</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">FLAGS_RW</span><span class="p">)</span>
<span class="n">img_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">img_dtype</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">FLAGS_RO</span><span class="p">)</span>
<span class="n">img32_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">img32_dtype</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">FLAGS_RO</span><span class="p">)</span>
<span class="n">kpts_array_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">kpts_t</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">FLAGS_RW</span><span class="p">)</span>
<span class="n">vecs_array_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">vecs_t</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">FLAGS_RW</span><span class="p">)</span>
<span class="n">int_array_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">int_t</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">FLAGS_RW</span><span class="p">)</span>
<span class="n">str_list_t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">str_t</span><span class="p">)</span>

<span class="c1"># THE ORDER OF THIS LIST IS IMPORTANT!</span>
<span class="n">HESAFF_TYPED_PARAMS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1"># Pyramid Params</span>
    <span class="p">(</span><span class="n">int_t</span><span class="p">,</span> <span class="s1">&#39;numberOfScales&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>  <span class="c1"># number of scale per octave</span>
    <span class="p">(</span>
        <span class="n">float_t</span><span class="p">,</span>
        <span class="s1">&#39;threshold&#39;</span><span class="p">,</span>
        <span class="mf">16.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">,</span>
    <span class="p">),</span>  <span class="c1"># noise dependent threshold on the response (sensitivity)</span>
    <span class="p">(</span><span class="n">float_t</span><span class="p">,</span> <span class="s1">&#39;edgeEigenValueRatio&#39;</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">),</span>  <span class="c1"># ratio of the eigenvalues</span>
    <span class="p">(</span><span class="n">int_t</span><span class="p">,</span> <span class="s1">&#39;border&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>  <span class="c1"># number of pixels ignored at the border of image</span>
    <span class="p">(</span>
        <span class="n">int_t</span><span class="p">,</span>
        <span class="s1">&#39;maxPyramidLevels&#39;</span><span class="p">,</span>
        <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">),</span>  <span class="c1"># maximum number of pyramid divisions. -1 is no limit</span>
    <span class="c1"># Affine Shape Params</span>
    <span class="p">(</span><span class="n">int_t</span><span class="p">,</span> <span class="s1">&#39;maxIterations&#39;</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>  <span class="c1"># number of affine shape interations</span>
    <span class="p">(</span>
        <span class="n">float_t</span><span class="p">,</span>
        <span class="s1">&#39;convergenceThreshold&#39;</span><span class="p">,</span>
        <span class="mf">0.05</span><span class="p">,</span>
    <span class="p">),</span>  <span class="c1"># maximum deviation from isotropic shape at convergence</span>
    <span class="p">(</span>
        <span class="n">int_t</span><span class="p">,</span>
        <span class="s1">&#39;smmWindowSize&#39;</span><span class="p">,</span>
        <span class="mi">19</span><span class="p">,</span>
    <span class="p">),</span>  <span class="c1"># width and height of the SMM (second moment matrix) mask</span>
    <span class="p">(</span>
        <span class="n">float_t</span><span class="p">,</span>
        <span class="s1">&#39;mrSize&#39;</span><span class="p">,</span>
        <span class="mf">3.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">),</span>
    <span class="p">),</span>  <span class="c1"># size of the measurement region (as multiple of the feature scale)</span>
    <span class="c1"># SIFT params</span>
    <span class="p">(</span><span class="n">int_t</span><span class="p">,</span> <span class="s1">&#39;spatialBins&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
    <span class="p">(</span><span class="n">int_t</span><span class="p">,</span> <span class="s1">&#39;orientationBins&#39;</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
    <span class="p">(</span><span class="n">float_t</span><span class="p">,</span> <span class="s1">&#39;maxBinValue&#39;</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">),</span>
    <span class="c1"># Shared params</span>
    <span class="p">(</span>
        <span class="n">float_t</span><span class="p">,</span>
        <span class="s1">&#39;initialSigma&#39;</span><span class="p">,</span>
        <span class="mf">1.6</span><span class="p">,</span>
    <span class="p">),</span>  <span class="c1"># amount of smoothing applied to the initial level of first octave</span>
    <span class="p">(</span><span class="n">int_t</span><span class="p">,</span> <span class="s1">&#39;patchSize&#39;</span><span class="p">,</span> <span class="mi">41</span><span class="p">),</span>  <span class="c1"># width and height of the patch</span>
    <span class="c1"># My params</span>
    <span class="p">(</span><span class="n">float_t</span><span class="p">,</span> <span class="s1">&#39;scale_min&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">),</span>
    <span class="p">(</span><span class="n">float_t</span><span class="p">,</span> <span class="s1">&#39;scale_max&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">),</span>
    <span class="p">(</span><span class="n">bool_t</span><span class="p">,</span> <span class="s1">&#39;rotation_invariance&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
    <span class="p">(</span><span class="n">bool_t</span><span class="p">,</span> <span class="s1">&#39;augment_orientation&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
    <span class="p">(</span><span class="n">float_t</span><span class="p">,</span> <span class="s1">&#39;ori_maxima_thresh&#39;</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span>
    <span class="p">(</span><span class="n">bool_t</span><span class="p">,</span> <span class="s1">&#39;affine_invariance&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
    <span class="p">(</span><span class="n">bool_t</span><span class="p">,</span> <span class="s1">&#39;only_count&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
    <span class="c1">#</span>
    <span class="p">(</span><span class="n">bool_t</span><span class="p">,</span> <span class="s1">&#39;use_dense&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
    <span class="p">(</span><span class="n">int_t</span><span class="p">,</span> <span class="s1">&#39;dense_stride&#39;</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span>
    <span class="p">(</span><span class="n">float_t</span><span class="p">,</span> <span class="s1">&#39;siftPower&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
<span class="p">]</span>

<span class="n">HESAFF_PARAM_DICT</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">type_</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">HESAFF_TYPED_PARAMS</span><span class="p">])</span>
<span class="n">HESAFF_PARAM_TYPES</span> <span class="o">=</span> <span class="p">[</span><span class="n">type_</span> <span class="k">for</span> <span class="p">(</span><span class="n">type_</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">HESAFF_TYPED_PARAMS</span><span class="p">]</span>


<div class="viewcode-block" id="grab_test_imgpath"><a class="viewcode-back" href="../../pyhesaff.html#pyhesaff._pyhesaff.grab_test_imgpath">[docs]</a><span class="k">def</span> <span class="nf">grab_test_imgpath</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">fpath</span> <span class="o">=</span> <span class="n">ub</span><span class="o">.</span><span class="n">grabdata</span><span class="p">(</span>
        <span class="s1">&#39;https://i.imgur.com/KXhKM72.png&#39;</span><span class="p">,</span>
        <span class="n">fname</span><span class="o">=</span><span class="s1">&#39;astro.png&#39;</span><span class="p">,</span>
        <span class="n">hash_prefix</span><span class="o">=</span><span class="s1">&#39;160b6e5989d2788c0296eac45b33e90fe612da23&#39;</span><span class="p">,</span>
        <span class="n">hasher</span><span class="o">=</span><span class="s1">&#39;sha1&#39;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">fpath</span></div>


<span class="k">def</span> <span class="nf">_build_typed_params_kwargs_docstr_block</span><span class="p">(</span><span class="n">typed_params</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        typed_params (dict):</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m pyhesaff build_typed_params_docstr</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from pyhesaff._pyhesaff import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; typed_params = HESAFF_TYPED_PARAMS</span>
<span class="sd">        &gt;&gt;&gt; result = build_typed_params_docstr(typed_params)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs_lines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">typed_params</span><span class="p">:</span>
        <span class="n">type_</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">default</span> <span class="o">=</span> <span class="n">tup</span>
        <span class="n">typestr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">type_</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&lt;class &#39;ctypes.c_&quot;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">line_fmtstr</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{name}</span><span class="s1"> (</span><span class="si">{typestr}</span><span class="s1">): default=</span><span class="si">{default}</span><span class="s1">&#39;</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line_fmtstr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">typestr</span><span class="o">=</span><span class="n">typestr</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">)</span>
        <span class="n">kwargs_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="n">kwargs_docstr_block</span> <span class="o">=</span> <span class="s1">&#39;Kwargs:</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">ub</span><span class="o">.</span><span class="n">indent</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">kwargs_lines</span><span class="p">),</span> <span class="s1">&#39;    &#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ub</span><span class="o">.</span><span class="n">indent</span><span class="p">(</span><span class="n">kwargs_docstr_block</span><span class="p">,</span> <span class="s1">&#39;    &#39;</span><span class="p">)</span>


<span class="n">hesaff_kwargs_docstr_block</span> <span class="o">=</span> <span class="n">_build_typed_params_kwargs_docstr_block</span><span class="p">(</span><span class="n">HESAFF_TYPED_PARAMS</span><span class="p">)</span>


<span class="n">HESAFF_CLIB</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">REBUILD_ONCE</span> <span class="o">=</span> <span class="mi">0</span>


<div class="viewcode-block" id="argparse_hesaff_params"><a class="viewcode-back" href="../../pyhesaff.html#pyhesaff._pyhesaff.argparse_hesaff_params">[docs]</a><span class="k">def</span> <span class="nf">argparse_hesaff_params</span><span class="p">():</span>
    <span class="n">alias_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;affine_invariance&#39;</span><span class="p">:</span> <span class="s1">&#39;ai&#39;</span><span class="p">}</span>
    <span class="n">alias_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;rotation_invariance&#39;</span><span class="p">:</span> <span class="s1">&#39;ri&#39;</span><span class="p">}</span>
    <span class="n">default_dict_</span> <span class="o">=</span> <span class="n">get_hesaff_default_params</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

        <span class="n">hesskw</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">argparse_dict</span><span class="p">(</span><span class="n">default_dict_</span><span class="p">,</span> <span class="n">alias_dict</span><span class="o">=</span><span class="n">alias_dict</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ex = </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ex</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">default_dict_</span>
    <span class="k">return</span> <span class="n">hesskw</span></div>


<span class="k">def</span> <span class="nf">_load_hesaff_clib</span><span class="p">(</span><span class="n">rebuild</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specificially loads the hesaff lib and defines its functions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">REBUILD_ONCE</span>
    <span class="c1"># Get the root directory which should have the dynamic library in it</span>
    <span class="c1"># root_dir = realpath(dirname(__file__)) if &#39;__file__&#39; in vars() else realpath(os.getcwd())</span>

    <span class="c1"># os.path.dirname(sys.executable)</span>
    <span class="c1"># if getattr(sys, &#39;frozen&#39;, False):</span>
    <span class="c1">#    # we are running in a |PyInstaller| bundle</span>
    <span class="c1">#     root_dir = realpath(sys._MEIPASS)</span>
    <span class="c1"># else:</span>
    <span class="c1">#    # we are running in a normal Python environment</span>
    <span class="c1">#    root_dir = realpath(dirname(__file__))</span>
    <span class="n">root_dir</span> <span class="o">=</span> <span class="n">realpath</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">rebuild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">REBUILD_ONCE</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="vm">__name__</span> <span class="o">!=</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
        <span class="n">REBUILD_ONCE</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">rebuild</span> <span class="o">=</span> <span class="n">ub</span><span class="o">.</span><span class="n">argflag</span><span class="p">(</span><span class="s1">&#39;--rebuild-hesaff&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rebuild</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;need to rebuild&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;REBUILDING HESAFF&#39;</span><span class="p">)</span>

    <span class="n">libname</span> <span class="o">=</span> <span class="s1">&#39;hesaff&#39;</span>
    <span class="p">(</span><span class="n">clib</span><span class="p">,</span> <span class="n">def_cfunc</span><span class="p">,</span> <span class="n">lib_fpath</span><span class="p">)</span> <span class="o">=</span> <span class="n">ctypes_interface</span><span class="o">.</span><span class="n">load_clib</span><span class="p">(</span><span class="n">libname</span><span class="p">,</span> <span class="n">root_dir</span><span class="p">)</span>
    <span class="c1"># Expose extern C Functions to hesaff&#39;s clib</span>
    <span class="c1"># def_cfunc(C.c_char_p, &#39;cmake_build_type&#39;,       [])</span>
    <span class="c1"># def_cfunc(None,  &#39;free_char&#39;,       [C.c_char_p])</span>
    <span class="n">def_cfunc</span><span class="p">(</span><span class="n">int_t</span><span class="p">,</span> <span class="s1">&#39;get_cpp_version&#39;</span><span class="p">,</span> <span class="p">[])</span>
    <span class="n">def_cfunc</span><span class="p">(</span><span class="n">int_t</span><span class="p">,</span> <span class="s1">&#39;is_debug_mode&#39;</span><span class="p">,</span> <span class="p">[])</span>
    <span class="n">def_cfunc</span><span class="p">(</span><span class="n">int_t</span><span class="p">,</span> <span class="s1">&#39;detect&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">obj_t</span><span class="p">])</span>
    <span class="n">def_cfunc</span><span class="p">(</span><span class="n">int_t</span><span class="p">,</span> <span class="s1">&#39;get_kpts_dim&#39;</span><span class="p">,</span> <span class="p">[])</span>
    <span class="n">def_cfunc</span><span class="p">(</span><span class="n">int_t</span><span class="p">,</span> <span class="s1">&#39;get_desc_dim&#39;</span><span class="p">,</span> <span class="p">[])</span>
    <span class="n">def_cfunc</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;exportArrays&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">obj_t</span><span class="p">,</span> <span class="n">int_t</span><span class="p">,</span> <span class="n">kpts_t</span><span class="p">,</span> <span class="n">vecs_t</span><span class="p">])</span>
    <span class="n">def_cfunc</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;extractDesc&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">obj_t</span><span class="p">,</span> <span class="n">int_t</span><span class="p">,</span> <span class="n">kpts_t</span><span class="p">,</span> <span class="n">vecs_t</span><span class="p">])</span>
    <span class="n">def_cfunc</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;extractPatches&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">obj_t</span><span class="p">,</span> <span class="n">int_t</span><span class="p">,</span> <span class="n">kpts_t</span><span class="p">,</span> <span class="n">img32_t</span><span class="p">])</span>
    <span class="n">def_cfunc</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;extractDescFromPatches&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">int_t</span><span class="p">,</span> <span class="n">int_t</span><span class="p">,</span> <span class="n">int_t</span><span class="p">,</span> <span class="n">img_t</span><span class="p">,</span> <span class="n">vecs_t</span><span class="p">])</span>
    <span class="n">def_cfunc</span><span class="p">(</span><span class="n">obj_t</span><span class="p">,</span> <span class="s1">&#39;new_hesaff_fpath&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">str_t</span><span class="p">]</span> <span class="o">+</span> <span class="n">HESAFF_PARAM_TYPES</span><span class="p">)</span>
    <span class="n">def_cfunc</span><span class="p">(</span>
        <span class="n">obj_t</span><span class="p">,</span> <span class="s1">&#39;new_hesaff_image&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">img_t</span><span class="p">,</span> <span class="n">int_t</span><span class="p">,</span> <span class="n">int_t</span><span class="p">,</span> <span class="n">int_t</span><span class="p">]</span> <span class="o">+</span> <span class="n">HESAFF_PARAM_TYPES</span>
    <span class="p">)</span>
    <span class="n">def_cfunc</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;free_hesaff&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">obj_t</span><span class="p">])</span>
    <span class="n">def_cfunc</span><span class="p">(</span><span class="n">obj_t</span><span class="p">,</span> <span class="s1">&#39;detectFeaturesListStep1&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">int_t</span><span class="p">,</span> <span class="n">str_list_t</span><span class="p">]</span> <span class="o">+</span> <span class="n">HESAFF_PARAM_TYPES</span><span class="p">)</span>
    <span class="n">def_cfunc</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;detectFeaturesListStep2&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">int_t</span><span class="p">,</span> <span class="n">obj_t</span><span class="p">,</span> <span class="n">int_array_t</span><span class="p">])</span>
    <span class="n">def_cfunc</span><span class="p">(</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="s1">&#39;detectFeaturesListStep3&#39;</span><span class="p">,</span>
        <span class="p">[</span><span class="n">int_t</span><span class="p">,</span> <span class="n">obj_t</span><span class="p">,</span> <span class="n">int_array_t</span><span class="p">,</span> <span class="n">int_array_t</span><span class="p">,</span> <span class="n">kpts_t</span><span class="p">,</span> <span class="n">vecs_t</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">clib</span><span class="p">,</span> <span class="n">lib_fpath</span>


<span class="c1"># Create a global interface to the hesaff lib</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">HESAFF_CLIB</span><span class="p">,</span> <span class="n">__LIB_FPATH__</span> <span class="o">=</span> <span class="n">_load_hesaff_clib</span><span class="p">()</span>
<span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Need to rebuild hesaff&#39;</span><span class="p">)</span>
    <span class="k">raise</span>

<span class="n">KPTS_DIM</span> <span class="o">=</span> <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">get_kpts_dim</span><span class="p">()</span>
<span class="n">DESC_DIM</span> <span class="o">=</span> <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">get_desc_dim</span><span class="p">()</span>


<span class="c1"># ============================</span>
<span class="c1"># helpers</span>
<span class="c1"># ============================</span>


<div class="viewcode-block" id="alloc_patches"><a class="viewcode-back" href="../../pyhesaff.html#pyhesaff._pyhesaff.alloc_patches">[docs]</a><span class="k">def</span> <span class="nf">alloc_patches</span><span class="p">(</span><span class="n">nKpts</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">41</span><span class="p">):</span>
    <span class="n">patches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nKpts</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">patches</span></div>


<div class="viewcode-block" id="alloc_vecs"><a class="viewcode-back" href="../../pyhesaff.html#pyhesaff._pyhesaff.alloc_vecs">[docs]</a><span class="k">def</span> <span class="nf">alloc_vecs</span><span class="p">(</span><span class="n">nKpts</span><span class="p">):</span>
    <span class="c1"># array of bytes</span>
    <span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nKpts</span><span class="p">,</span> <span class="n">DESC_DIM</span><span class="p">),</span> <span class="n">vecs_dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vecs</span></div>


<div class="viewcode-block" id="alloc_kpts"><a class="viewcode-back" href="../../pyhesaff.html#pyhesaff._pyhesaff.alloc_kpts">[docs]</a><span class="k">def</span> <span class="nf">alloc_kpts</span><span class="p">(</span><span class="n">nKpts</span><span class="p">):</span>
    <span class="c1"># array of floats</span>
    <span class="n">kpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nKpts</span><span class="p">,</span> <span class="n">KPTS_DIM</span><span class="p">),</span> <span class="n">kpts_dtype</span><span class="p">)</span>
    <span class="c1"># kpts = np.zeros((nKpts, KPTS_DIM), kpts_dtype) - 1.0  # array of floats</span>
    <span class="k">return</span> <span class="n">kpts</span></div>


<span class="k">def</span> <span class="nf">_make_hesaff_cpp_params</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">hesaff_params</span> <span class="o">=</span> <span class="n">HESAFF_PARAM_DICT</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">hesaff_params</span><span class="p">:</span>
            <span class="n">hesaff_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[pyhesaff] WARNING: key=</span><span class="si">%r</span><span class="s1"> is not known&#39;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hesaff_params</span>


<span class="k">def</span> <span class="nf">_cast_strlist_to_C</span><span class="p">(</span><span class="n">py_strlist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a python list of strings into a c array of strings</span>

<span class="sd">    References:</span>
<span class="sd">        http://stackoverflow.com/questions/3494598/pass-list-of-strings-ctypes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">c_strarr</span> <span class="o">=</span> <span class="p">(</span><span class="n">str_t</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">py_strlist</span><span class="p">))()</span>
    <span class="n">c_strarr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">py_strlist</span>
    <span class="k">return</span> <span class="n">c_strarr</span>


<span class="k">def</span> <span class="nf">_new_fpath_hesaff</span><span class="p">(</span><span class="n">img_fpath</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates new detector object which reads the image &quot;&quot;&quot;</span>
    <span class="n">hesaff_params</span> <span class="o">=</span> <span class="n">_make_hesaff_cpp_params</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">hesaff_args</span> <span class="o">=</span> <span class="n">hesaff_params</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>  <span class="c1"># pass all parameters to HESAFF_CLIB</span>
    <span class="n">img_realpath</span> <span class="o">=</span> <span class="n">realpath</span><span class="p">(</span><span class="n">img_fpath</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">PY3</span><span class="p">:</span>
        <span class="c1"># convert out of unicode</span>
        <span class="n">img_realpath</span> <span class="o">=</span> <span class="n">img_realpath</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">hesaff_ptr</span> <span class="o">=</span> <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">new_hesaff_fpath</span><span class="p">(</span><span class="n">img_realpath</span><span class="p">,</span> <span class="o">*</span><span class="n">hesaff_args</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;hesaff_ptr = HESAFF_CLIB.new_hesaff_fpath(img_realpath, *hesaff_args)&#39;</span><span class="p">,)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;msg = </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hesaff_args = </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hesaff_args</span><span class="p">))</span>
        <span class="k">raise</span>
    <span class="k">return</span> <span class="n">hesaff_ptr</span>


<span class="k">def</span> <span class="nf">_new_image_hesaff</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates new detector object which reads the image &quot;&quot;&quot;</span>
    <span class="n">hesaff_params</span> <span class="o">=</span> <span class="n">_make_hesaff_cpp_params</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">hesaff_args</span> <span class="o">=</span> <span class="n">hesaff_params</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>  <span class="c1"># pass all parameters to HESAFF_CLIB</span>
    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">hesaff_ptr</span> <span class="o">=</span> <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">new_hesaff_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="o">*</span><span class="n">hesaff_args</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;hesaff_ptr = &#39;</span> <span class="s1">&#39;HESAFF_CLIB.new_hesaff_image(img_realpath, *hesaff_args)&#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;msg = </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hesaff_args = </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hesaff_args</span><span class="p">))</span>
        <span class="k">raise</span>
    <span class="k">return</span> <span class="n">hesaff_ptr</span>


<span class="c1"># ============================</span>
<span class="c1"># hesaff python interface</span>
<span class="c1"># ============================</span>


<div class="viewcode-block" id="get_hesaff_default_params"><a class="viewcode-back" href="../../pyhesaff.html#pyhesaff._pyhesaff.get_hesaff_default_params">[docs]</a><span class="k">def</span> <span class="nf">get_hesaff_default_params</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">HESAFF_PARAM_DICT</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="get_is_debug_mode"><a class="viewcode-back" href="../../pyhesaff.html#pyhesaff._pyhesaff.get_is_debug_mode">[docs]</a><span class="k">def</span> <span class="nf">get_is_debug_mode</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">is_debug_mode</span><span class="p">()</span></div>


<div class="viewcode-block" id="get_cpp_version"><a class="viewcode-back" href="../../pyhesaff.html#pyhesaff._pyhesaff.get_cpp_version">[docs]</a><span class="k">def</span> <span class="nf">get_cpp_version</span><span class="p">():</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns:</span>
<span class="sd">        int: cpp_version</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m pyhesaff get_cpp_version</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from pyhesaff._pyhesaff import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; cpp_version = get_cpp_version()</span>
<span class="sd">        &gt;&gt;&gt; isdebug = get_is_debug_mode()</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;cpp_version = %r&#39; % (cpp_version,))</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;isdebug = %r&#39; % (isdebug,))</span>
<span class="sd">        &gt;&gt;&gt; assert cpp_version == 3, &#39;cpp version mimatch&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># str_ptr = HESAFF_CLIB.cmake_build_type()</span>
    <span class="c1"># copy c string into python</span>
    <span class="c1"># pystr = C.c_char_p(str_ptr).value</span>
    <span class="c1"># need to free c string</span>
    <span class="c1"># HESAFF_CLIB.free_char(str_ptr)</span>
    <span class="c1"># print(&#39;pystr = %r&#39; % (pystr,))</span>
    <span class="c1"># print(&#39;pystr = %s&#39; % (pystr,))</span>
    <span class="n">cpp_version</span> <span class="o">=</span> <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">get_cpp_version</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">cpp_version</span></div>


<span class="c1"># full detection and extraction</span>


<div class="viewcode-block" id="detect_feats"><a class="viewcode-back" href="../../pyhesaff.html#pyhesaff._pyhesaff.detect_feats">[docs]</a><span class="k">def</span> <span class="nf">detect_feats</span><span class="p">(</span><span class="n">img_fpath</span><span class="p">,</span> <span class="n">use_adaptive_scale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nogravity_hack</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    driver function for detecting hessian affine keypoints from an image path.</span>
<span class="sd">    extra parameters can be passed to the hessian affine detector by using</span>
<span class="sd">    kwargs.</span>

<span class="sd">    Args:</span>
<span class="sd">        img_fpath (str): image file path on disk</span>
<span class="sd">        use_adaptive_scale (bool):</span>
<span class="sd">        nogravity_hack (bool):</span>

<span class="sd">    Kwargs:</span>
<span class="sd">        numberOfScales (int)         : default=3</span>
<span class="sd">        threshold (float)            : default=5.33333333333</span>
<span class="sd">        edgeEigenValueRatio (float)  : default=10.0</span>
<span class="sd">        border (int)                 : default=5</span>
<span class="sd">        maxIterations (int)          : default=16</span>
<span class="sd">        convergenceThreshold (float) : default=0.05</span>
<span class="sd">        smmWindowSize (int)          : default=19</span>
<span class="sd">        mrSize (float)               : default=5.19615242271</span>
<span class="sd">        spatialBins (int)            : default=4</span>
<span class="sd">        orientationBins (int)        : default=8</span>
<span class="sd">        maxBinValue (float)          : default=0.2</span>
<span class="sd">        initialSigma (float)         : default=1.6</span>
<span class="sd">        patchSize (int)              : default=41</span>
<span class="sd">        scale_min (float)            : default=-1.0</span>
<span class="sd">        scale_max (float)            : default=-1.0</span>
<span class="sd">        rotation_invariance (bool)   : default=False</span>
<span class="sd">        affine_invariance (bool)     : default=True</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple : (kpts, vecs)</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m pyhesaff detect_feats</span>
<span class="sd">        python -m pyhesaff detect_feats --show</span>
<span class="sd">        python -m pyhesaff detect_feats --show --fname star.png</span>
<span class="sd">        python -m pyhesaff detect_feats --show --fname zebra.png</span>
<span class="sd">        python -m pyhesaff detect_feats --show --fname astro.png</span>
<span class="sd">        python -m pyhesaff detect_feats --show --fname carl.jpg</span>

<span class="sd">        python -m pyhesaff detect_feats --show --fname astro.png --ri</span>
<span class="sd">        python -m pyhesaff detect_feats --show --fname astro.png --ai</span>

<span class="sd">        python -m pyhesaff detect_feats --show --fname easy1.png --no-ai</span>
<span class="sd">        python -m pyhesaff detect_feats --show --fname easy1.png --no-ai --numberOfScales=1 --verbose</span>
<span class="sd">        python -m pyhesaff detect_feats --show --fname easy1.png --no-ai --scale-max=100 --verbose</span>
<span class="sd">        python -m pyhesaff detect_feats --show --fname easy1.png --no-ai --scale-min=20 --verbose</span>
<span class="sd">        python -m pyhesaff detect_feats --show --fname easy1.png --no-ai --scale-min=100 --verbose</span>
<span class="sd">        python -m pyhesaff detect_feats --show --fname easy1.png --no-ai --scale-max=20 --verbose</span>

<span class="sd">        python -m vtool.test_constrained_matching visualize_matches --show</span>
<span class="sd">        python -m vtool.tests.dummy testdata_ratio_matches --show</span>

<span class="sd">        python -m pyhesaff detect_feats --show --fname easy1.png --ai \</span>
<span class="sd">            --verbose --rebuild-hesaff --scale-min=35 --scale-max=40 --no-rmbuild</span>

<span class="sd">        python -m pyhesaff detect_feats --show --fname easy1.png --ai \</span>
<span class="sd">            --verbose --scale-min=35 --scale-max=40&amp;</span>
<span class="sd">        python -m pyhesaff detect_feats --show --fname easy1.png --no-ai \</span>
<span class="sd">            --verbose --scale-min=35 --scale-max=40&amp;</span>
<span class="sd">        python -m pyhesaff detect_feats --show --fname easy1.png --no-ai \</span>
<span class="sd">            --verbose --scale-max=40 --darken .5</span>
<span class="sd">        python -m pyhesaff detect_feats --show --fname easy1.png --no-ai \</span>
<span class="sd">            --verbose --scale-max=30 --darken .5</span>
<span class="sd">        python -m pyhesaff detect_feats --show --fname easy1.png --ai \</span>
<span class="sd">            --verbose --scale-max=30 --darken .5</span>

<span class="sd">        # DENSE KEYPOINTS</span>
<span class="sd">        python -m pyhesaff detect_feats --show --fname astro.png \</span>
<span class="sd">            --no-affine-invariance --numberOfScales=1 --maxPyramidLevels=1 \</span>
<span class="sd">            --use_dense --dense_stride=64</span>
<span class="sd">        python -m pyhesaff detect_feats --show --fname astro.png \</span>
<span class="sd">            --no-affine-invariance --numberOfScales=1 --maxPyramidLevels=1 \</span>
<span class="sd">            --use_dense --dense_stride=64 --rotation-invariance</span>
<span class="sd">        python -m pyhesaff detect_feats --show --fname astro.png \</span>
<span class="sd">            --affine-invariance --numberOfScales=1 --maxPyramidLevels=1 \</span>
<span class="sd">            --use_dense --dense_stride=64</span>
<span class="sd">        python -m pyhesaff detect_feats --show --fname astro.png \</span>
<span class="sd">            --no-affine-invariance --numberOfScales=3 \</span>
<span class="sd">            --maxPyramidLevels=2 --use_dense --dense_stride=32</span>

<span class="sd">        python -m pyhesaff detect_feats --show --only_count=False</span>

<span class="sd">    Example0:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; # Test simple detect</span>
<span class="sd">        &gt;&gt;&gt; from pyhesaff._pyhesaff import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import vtool as vt</span>
<span class="sd">        &gt;&gt;&gt; TAU = 2 * np.pi</span>
<span class="sd">        &gt;&gt;&gt; fpath = grab_test_imgpath(ub.argval(&#39;--fname&#39;, default=&#39;astro.png&#39;))</span>
<span class="sd">        &gt;&gt;&gt; theta = float(ub.argval(&#39;--theta&#39;, 0))  # TAU * 3 / 8)</span>
<span class="sd">        &gt;&gt;&gt; img_fpath = vt.rotate_image_ondisk(fpath, theta)</span>
<span class="sd">        &gt;&gt;&gt; kwargs = argparse_hesaff_params()</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;kwargs = %r&#39; % (kwargs,))</span>
<span class="sd">        &gt;&gt;&gt; (kpts, vecs) = detect_feats(img_fpath, **kwargs)</span>
<span class="sd">        &gt;&gt;&gt; # Show keypoints</span>
<span class="sd">        &gt;&gt;&gt; # xdoctest: +REQUIRES(--show)</span>
<span class="sd">        &gt;&gt;&gt; imgBGR = vt.imread(img_fpath)</span>
<span class="sd">        &gt;&gt;&gt; # take a random stample</span>
<span class="sd">        &gt;&gt;&gt; frac = ub.argval(&#39;--frac&#39;, default=1.0)</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;frac = %r&#39; % (frac,))</span>
<span class="sd">        &gt;&gt;&gt; idxs = vecs[0:int(len(vecs) * frac]</span>
<span class="sd">        &gt;&gt;&gt; vecs, kpts = vecs[idxs], kpts[idxs]</span>
<span class="sd">        &gt;&gt;&gt; default_showkw = dict(ori=False, ell=True, ell_linewidth=2,</span>
<span class="sd">        &gt;&gt;&gt;                       ell_alpha=.4, ell_color=&#39;distinct&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;default_showkw = %r&#39; % (default_showkw,))</span>
<span class="sd">        &gt;&gt;&gt; #showkw = ut.argparse_dict(default_showkw)</span>
<span class="sd">        &gt;&gt;&gt; #import plottool as pt</span>
<span class="sd">        &gt;&gt;&gt; #pt.interact_keypoints.ishow_keypoints(imgBGR, kpts, vecs, **showkw)</span>
<span class="sd">        &gt;&gt;&gt; #pt.show_if_requested()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load image</span>
    <span class="n">hesaff_ptr</span> <span class="o">=</span> <span class="n">_new_fpath_hesaff</span><span class="p">(</span><span class="n">img_fpath</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># Get num detected</span>
    <span class="n">nKpts</span> <span class="o">=</span> <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">detect</span><span class="p">(</span><span class="n">hesaff_ptr</span><span class="p">)</span>
    <span class="c1"># Allocate arrays</span>
    <span class="n">kpts</span> <span class="o">=</span> <span class="n">alloc_kpts</span><span class="p">(</span><span class="n">nKpts</span><span class="p">)</span>
    <span class="n">vecs</span> <span class="o">=</span> <span class="n">alloc_vecs</span><span class="p">(</span><span class="n">nKpts</span><span class="p">)</span>
    <span class="c1"># Populate arrays</span>
    <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">exportArrays</span><span class="p">(</span><span class="n">hesaff_ptr</span><span class="p">,</span> <span class="n">nKpts</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">vecs</span><span class="p">)</span>
    <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">free_hesaff</span><span class="p">(</span><span class="n">hesaff_ptr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_adaptive_scale</span><span class="p">:</span>  <span class="c1"># Adapt scale if requested</span>
        <span class="n">kpts</span><span class="p">,</span> <span class="n">vecs</span> <span class="o">=</span> <span class="n">adapt_scale</span><span class="p">(</span><span class="n">img_fpath</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nogravity_hack</span><span class="p">:</span>
        <span class="n">kpts</span><span class="p">,</span> <span class="n">vecs</span> <span class="o">=</span> <span class="n">vtool_adapt_rotation</span><span class="p">(</span><span class="n">img_fpath</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">vecs</span></div>


<div class="viewcode-block" id="detect_feats2"><a class="viewcode-back" href="../../pyhesaff.html#pyhesaff._pyhesaff.detect_feats2">[docs]</a><span class="k">def</span> <span class="nf">detect_feats2</span><span class="p">(</span><span class="n">img_or_fpath</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    General way of detecting from either an fpath or ndarray</span>

<span class="sd">    Args:</span>
<span class="sd">        img_or_fpath (str or ndarray):  file path string</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img_or_fpath</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="n">fpath</span> <span class="o">=</span> <span class="n">img_or_fpath</span>
        <span class="k">return</span> <span class="n">detect_feats</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img_or_fpath</span>
        <span class="k">return</span> <span class="n">detect_feats_in_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="detect_feats_list"><a class="viewcode-back" href="../../pyhesaff.html#pyhesaff._pyhesaff.detect_feats_list">[docs]</a><span class="k">def</span> <span class="nf">detect_feats_list</span><span class="p">(</span><span class="n">image_paths_list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        image_paths_list (list): A list of image paths</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: (kpts_list, vecs_list) A tuple of lists of keypoints and decsriptors</span>

<span class="sd">    Kwargs:</span>
<span class="sd">        numberOfScales (int)         : default=3</span>
<span class="sd">        threshold (float)            : default=5.33333333333</span>
<span class="sd">        edgeEigenValueRatio (float)  : default=10.0</span>
<span class="sd">        border (int)                 : default=5</span>
<span class="sd">        maxIterations (int)          : default=16</span>
<span class="sd">        convergenceThreshold (float) : default=0.05</span>
<span class="sd">        smmWindowSize (int)          : default=19</span>
<span class="sd">        mrSize (float)               : default=5.19615242271</span>
<span class="sd">        spatialBins (int)            : default=4</span>
<span class="sd">        orientationBins (int)        : default=8</span>
<span class="sd">        maxBinValue (float)          : default=0.2</span>
<span class="sd">        initialSigma (float)         : default=1.6</span>
<span class="sd">        patchSize (int)              : default=41</span>
<span class="sd">        scale_min (float)            : default=-1.0</span>
<span class="sd">        scale_max (float)            : default=-1.0</span>
<span class="sd">        rotation_invariance (bool)   : default=False</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m pyhesaff._pyhesaff detect_feats_list --show</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from pyhesaff._pyhesaff import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; fpath = grab_test_imgpath(&#39;astro.png&#39;)</span>
<span class="sd">        &gt;&gt;&gt; image_paths_list = [grab_test_imgpath(&#39;carl.jpg&#39;), grab_test_imgpath(&#39;star.png&#39;), fpath]</span>
<span class="sd">        &gt;&gt;&gt; (kpts_list, vecs_list) = detect_feats_list(image_paths_list)</span>
<span class="sd">        &gt;&gt;&gt; #print((kpts_list, vecs_list))</span>
<span class="sd">        &gt;&gt;&gt; # Assert that the normal version agrees</span>
<span class="sd">        &gt;&gt;&gt; serial_list = [detect_feats(fpath) for fpath in image_paths_list]</span>
<span class="sd">        &gt;&gt;&gt; kpts_list2 = [c[0] for c in serial_list]</span>
<span class="sd">        &gt;&gt;&gt; vecs_list2 = [c[1] for c in serial_list]</span>
<span class="sd">        &gt;&gt;&gt; diff_kpts = [kpts - kpts2 for kpts, kpts2 in zip(kpts_list, kpts_list2)]</span>
<span class="sd">        &gt;&gt;&gt; diff_vecs = [vecs - vecs2 for vecs, vecs2 in zip(vecs_list, vecs_list2)]</span>
<span class="sd">        &gt;&gt;&gt; assert all([x.sum() == 0 for x in diff_kpts]), &#39;inconsistent results&#39;</span>
<span class="sd">        &gt;&gt;&gt; assert all([x.sum() == 0 for x in diff_vecs]), &#39;inconsistent results&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get Num Images</span>
    <span class="n">num_imgs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_paths_list</span><span class="p">)</span>

    <span class="c1"># Cast string list to C</span>
    <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">PY2</span><span class="p">:</span>
        <span class="n">realpaths_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">realpath</span><span class="p">,</span> <span class="n">image_paths_list</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">PY3</span><span class="p">:</span>
        <span class="n">realpaths_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">realpath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">image_paths_list</span><span class="p">]</span>

    <span class="n">c_strs</span> <span class="o">=</span> <span class="n">_cast_strlist_to_C</span><span class="p">(</span><span class="n">realpaths_list</span><span class="p">)</span>

    <span class="c1"># Get algorithm parameters</span>
    <span class="n">hesaff_params</span> <span class="o">=</span> <span class="n">HESAFF_PARAM_DICT</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">hesaff_params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># pass all parameters to HESAFF_CLIB</span>
    <span class="n">hesaff_args</span> <span class="o">=</span> <span class="n">hesaff_params</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="n">length_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">num_imgs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int_t</span><span class="p">)</span>
    <span class="n">detector_array</span> <span class="o">=</span> <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">detectFeaturesListStep1</span><span class="p">(</span><span class="n">num_imgs</span><span class="p">,</span> <span class="n">c_strs</span><span class="p">,</span> <span class="o">*</span><span class="n">hesaff_args</span><span class="p">)</span>
    <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">detectFeaturesListStep2</span><span class="p">(</span><span class="n">num_imgs</span><span class="p">,</span> <span class="n">detector_array</span><span class="p">,</span> <span class="n">length_array</span><span class="p">)</span>
    <span class="n">total_pts</span> <span class="o">=</span> <span class="n">length_array</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="c1"># allocate arrays</span>
    <span class="n">total_num_arrays</span> <span class="o">=</span> <span class="n">num_imgs</span> <span class="o">*</span> <span class="n">total_pts</span>
    <span class="n">flat_kpts_ptr</span> <span class="o">=</span> <span class="n">alloc_kpts</span><span class="p">(</span><span class="n">total_num_arrays</span><span class="p">)</span>
    <span class="n">flat_vecs_ptr</span> <span class="o">=</span> <span class="n">alloc_vecs</span><span class="p">(</span><span class="n">total_num_arrays</span><span class="p">)</span>
    <span class="c1"># TODO: get this working</span>
    <span class="n">offset_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">length_array</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int_t</span><span class="p">)</span>
    <span class="c1"># np.array([0] + length_array.cumsum().tolist()[0:-1], int_t)</span>
    <span class="n">offset_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">detectFeaturesListStep3</span><span class="p">(</span>
        <span class="n">num_imgs</span><span class="p">,</span> <span class="n">detector_array</span><span class="p">,</span> <span class="n">length_array</span><span class="p">,</span> <span class="n">offset_array</span><span class="p">,</span> <span class="n">flat_kpts_ptr</span><span class="p">,</span> <span class="n">flat_vecs_ptr</span>
    <span class="p">)</span>

    <span class="c1"># reshape into jagged arrays</span>
    <span class="n">kpts_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">flat_kpts_ptr</span><span class="p">[</span><span class="n">o</span> <span class="p">:</span> <span class="n">o</span> <span class="o">+</span> <span class="n">l</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">offset_array</span><span class="p">,</span> <span class="n">length_array</span><span class="p">)]</span>
    <span class="n">vecs_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">flat_vecs_ptr</span><span class="p">[</span><span class="n">o</span> <span class="p">:</span> <span class="n">o</span> <span class="o">+</span> <span class="n">l</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">offset_array</span><span class="p">,</span> <span class="n">length_array</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">kpts_list</span><span class="p">,</span> <span class="n">vecs_list</span></div>


<div class="viewcode-block" id="detect_feats_in_image"><a class="viewcode-back" href="../../pyhesaff.html#pyhesaff._pyhesaff.detect_feats_in_image">[docs]</a><span class="k">def</span> <span class="nf">detect_feats_in_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a preloaded image and detects keypoints and descriptors</span>

<span class="sd">    Args:</span>
<span class="sd">        img (ndarray[uint8_t, ndim=2]):  image data, should be in BGR or grayscale</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: (kpts, vecs)</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m pyhesaff detect_feats_in_image --show</span>
<span class="sd">        python -m pyhesaff detect_feats_in_image --rebuild-hesaff --show --no-rmbuild</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from pyhesaff._pyhesaff import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import vtool as vt</span>
<span class="sd">        &gt;&gt;&gt; img_fpath = grab_test_imgpath(&#39;astro.png&#39;)</span>
<span class="sd">        &gt;&gt;&gt; img= vt.imread(img_fpath)</span>
<span class="sd">        &gt;&gt;&gt; (kpts, vecs) = detect_feats_in_image(img)</span>
<span class="sd">        &gt;&gt;&gt; # xdoctest: +REQUIRES(--show)</span>
<span class="sd">        &gt;&gt;&gt; import plottool as pt</span>
<span class="sd">        &gt;&gt;&gt; pt.interact_keypoints.ishow_keypoints(img, kpts, vecs, ori=True,</span>
<span class="sd">        &gt;&gt;&gt;                                       ell_alpha=.4, color=&#39;distinct&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pt.set_figtitle(&#39;Detect Kpts in Image&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pt.show_if_requested()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Valid keyword arguments are: + str(HESAFF_PARAM_DICT.keys())</span>
    <span class="n">hesaff_ptr</span> <span class="o">=</span> <span class="n">_new_image_hesaff</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># Get num detected</span>
    <span class="n">nKpts</span> <span class="o">=</span> <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">detect</span><span class="p">(</span><span class="n">hesaff_ptr</span><span class="p">)</span>
    <span class="c1"># Allocate arrays</span>
    <span class="n">kpts</span> <span class="o">=</span> <span class="n">alloc_kpts</span><span class="p">(</span><span class="n">nKpts</span><span class="p">)</span>
    <span class="n">vecs</span> <span class="o">=</span> <span class="n">alloc_vecs</span><span class="p">(</span><span class="n">nKpts</span><span class="p">)</span>
    <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">exportArrays</span><span class="p">(</span><span class="n">hesaff_ptr</span><span class="p">,</span> <span class="n">nKpts</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">vecs</span><span class="p">)</span>  <span class="c1"># Populate arrays</span>
    <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">free_hesaff</span><span class="p">(</span><span class="n">hesaff_ptr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">vecs</span></div>


<div class="viewcode-block" id="detect_num_feats_in_image"><a class="viewcode-back" href="../../pyhesaff.html#pyhesaff._pyhesaff.detect_num_feats_in_image">[docs]</a><span class="k">def</span> <span class="nf">detect_num_feats_in_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Just quickly returns how many keypoints are in the image. Does not attempt</span>
<span class="sd">    to return or store the values.</span>

<span class="sd">    It is a good idea to turn off things like ai and ri here.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (ndarray[uint8_t, ndim=2]):  image data</span>

<span class="sd">    Returns:</span>
<span class="sd">        int: nKpts</span>

<span class="sd">    ISSUE: there seems to be an inconsistency for jpgs between this and detect_feats</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m pyhesaff detect_num_feats_in_image:0 --show</span>
<span class="sd">        python -m pyhesaff detect_num_feats_in_image:1 --show</span>
<span class="sd">        python -m xdoctest pyhesaff detect_num_feats_in_image:0</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from pyhesaff._pyhesaff import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import vtool as vt</span>
<span class="sd">        &gt;&gt;&gt; img_fpath = grab_test_imgpath(&#39;zebra.png&#39;)</span>
<span class="sd">        &gt;&gt;&gt; img = vt.imread(img_fpath)</span>
<span class="sd">        &gt;&gt;&gt; nKpts = detect_num_feats_in_image(img)</span>
<span class="sd">        &gt;&gt;&gt; kpts, vecs = detect_feats_in_image(img)</span>
<span class="sd">        &gt;&gt;&gt; #assert nKpts == len(kpts), &#39;inconsistency&#39;</span>
<span class="sd">        &gt;&gt;&gt; result = (&#39;nKpts = %s&#39; % (ub.repr2(nKpts),))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>

<span class="sd">    Example1:</span>
<span class="sd">        &gt;&gt;&gt; # TIMEDOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from pyhesaff._pyhesaff import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; setup = ub.codeblock(</span>
<span class="sd">            &#39;&#39;&#39;</span>
<span class="sd">            import vtool as vt</span>
<span class="sd">            import pyhesaff</span>
<span class="sd">            img_fpath = grab_test_imgpath(&#39;carl.jpg&#39;)</span>
<span class="sd">            img = vt.imread(img_fpath)</span>
<span class="sd">            &#39;&#39;&#39;)</span>
<span class="sd">        &gt;&gt;&gt; stmt_list = [</span>
<span class="sd">        &gt;&gt;&gt;    &#39;pyhesaff.detect_feats_in_image(img)&#39;,</span>
<span class="sd">        &gt;&gt;&gt;    &#39;pyhesaff.detect_num_feats_in_image(img, affine_invariance=False)&#39;,</span>
<span class="sd">        &gt;&gt;&gt;    &#39;pyhesaff.detect_num_feats_in_image(img)&#39;,</span>
<span class="sd">        &gt;&gt;&gt; ]</span>
<span class="sd">        &gt;&gt;&gt; iterations = 30</span>
<span class="sd">        &gt;&gt;&gt; verbose = True</span>
<span class="sd">        &gt;&gt;&gt; #ut.timeit_compare(stmt_list, setup=setup, iterations=iterations,</span>
<span class="sd">        &gt;&gt;&gt; #                  verbose=verbose, assertsame=False)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We dont need to find vectors at all here</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;only_count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># kwargs[&#39;only_count&#39;] = False</span>
    <span class="c1"># Valid keyword arguments are: + str(HESAFF_PARAM_DICT.keys())</span>
    <span class="n">hesaff_ptr</span> <span class="o">=</span> <span class="n">_new_image_hesaff</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># Get num detected</span>
    <span class="n">nKpts</span> <span class="o">=</span> <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">detect</span><span class="p">(</span><span class="n">hesaff_ptr</span><span class="p">)</span>
    <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">free_hesaff</span><span class="p">(</span><span class="n">hesaff_ptr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nKpts</span></div>


<span class="c1"># just extraction</span>


<div class="viewcode-block" id="extract_vecs"><a class="viewcode-back" href="../../pyhesaff.html#pyhesaff._pyhesaff.extract_vecs">[docs]</a><span class="k">def</span> <span class="nf">extract_vecs</span><span class="p">(</span><span class="n">img_fpath</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract SIFT descriptors at keypoint locations</span>

<span class="sd">    Args:</span>
<span class="sd">        img_fpath (str):</span>
<span class="sd">        kpts (ndarray[float32_t, ndim=2]):  keypoints</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray[uint8_t, ndim=2]: vecs -  descriptor vectors</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m pyhesaff extract_vecs:0</span>
<span class="sd">        python -m pyhesaff extract_vecs:1 --fname=astro.png</span>
<span class="sd">        python -m pyhesaff extract_vecs:1 --fname=patsy.jpg --show</span>
<span class="sd">        python -m pyhesaff extract_vecs:1 --fname=carl.jpg</span>
<span class="sd">        python -m pyhesaff extract_vecs:1 --fname=zebra.png</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from pyhesaff._pyhesaff import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import vtool as vt</span>
<span class="sd">        &gt;&gt;&gt; img_fpath = grab_test_imgpath(&#39;carl.jpg&#39;)</span>
<span class="sd">        &gt;&gt;&gt; kpts = vt.demodata.get_dummy_kpts()</span>
<span class="sd">        &gt;&gt;&gt; vecs = extract_vecs(img_fpath, kpts)</span>
<span class="sd">        &gt;&gt;&gt; result = (&#39;vecs = %s&#39; % (str(vecs),))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from pyhesaff._pyhesaff import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import vtool as vt</span>
<span class="sd">        &gt;&gt;&gt; img_fpath = grab_test_imgpath(ub.argval(&#39;--fname&#39;, default=&#39;astro.png&#39;))</span>
<span class="sd">        &gt;&gt;&gt; # Extract original keypoints</span>
<span class="sd">        &gt;&gt;&gt; kpts, vecs1 = detect_feats(img_fpath)</span>
<span class="sd">        &gt;&gt;&gt; # Re-extract keypoints</span>
<span class="sd">        &gt;&gt;&gt; vecs2 = extract_vecs(img_fpath, kpts)</span>
<span class="sd">        &gt;&gt;&gt; # Descriptors should be the same</span>
<span class="sd">        &gt;&gt;&gt; errors = vt.L2_sift(vecs1, vecs2)</span>
<span class="sd">        &gt;&gt;&gt; errors_index = np.nonzero(errors)[0]</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;errors = %r&#39; % (errors,))</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;errors_index = %r&#39; % (errors_index,))</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;errors.sum() = %r&#39; % (errors.sum(),))</span>
<span class="sd">        &gt;&gt;&gt; # VISUALIZTION</span>
<span class="sd">        &gt;&gt;&gt; # xdoctest: +REQUIRES(--show)</span>
<span class="sd">        &gt;&gt;&gt; import plottool as pt</span>
<span class="sd">        &gt;&gt;&gt; # Extract the underlying grayscale patches</span>
<span class="sd">        &gt;&gt;&gt; img = vt.imread(img_fpath)</span>
<span class="sd">        &gt;&gt;&gt; #patch_list_ = np.array(vt.get_warped_patches(img, kpts)[0])</span>
<span class="sd">        &gt;&gt;&gt; #patch_list = np.array(vt.convert_image_list_colorspace(patch_list_, &#39;gray&#39;))</span>
<span class="sd">        &gt;&gt;&gt; patch_list = extract_patches(img, kpts)</span>
<span class="sd">        &gt;&gt;&gt; pt.interact_keypoints.ishow_keypoints(img_fpath, kpts[errors_index], vecs1[errors_index], fnum=1)</span>
<span class="sd">        &gt;&gt;&gt; ax = pt.draw_patches_and_sifts(patch_list[errors_index], vecs1[errors_index], pnum=(1, 2, 1), fnum=2)</span>
<span class="sd">        &gt;&gt;&gt; ax.set_title(&#39;patch extracted&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ax = pt.draw_patches_and_sifts(patch_list[errors_index], vecs2[errors_index], pnum=(1, 2, 2), fnum=2)</span>
<span class="sd">        &gt;&gt;&gt; ax.set_title(&#39;image extracted&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pt.set_figtitle(&#39;Error Keypoints&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pt.show_if_requested()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hesaff_ptr</span> <span class="o">=</span> <span class="n">_new_fpath_hesaff</span><span class="p">(</span><span class="n">img_fpath</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">nKpts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kpts</span><span class="p">)</span>
    <span class="c1"># allocate memory for new decsriptors</span>
    <span class="n">vecs</span> <span class="o">=</span> <span class="n">alloc_vecs</span><span class="p">(</span><span class="n">nKpts</span><span class="p">)</span>
    <span class="c1"># kpts might not be contiguous</span>
    <span class="n">kpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">kpts</span><span class="p">)</span>
    <span class="c1"># extract decsriptors at given locations</span>
    <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">extractDesc</span><span class="p">(</span><span class="n">hesaff_ptr</span><span class="p">,</span> <span class="n">nKpts</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">vecs</span><span class="p">)</span>
    <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">free_hesaff</span><span class="p">(</span><span class="n">hesaff_ptr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vecs</span></div>


<div class="viewcode-block" id="extract_patches"><a class="viewcode-back" href="../../pyhesaff.html#pyhesaff._pyhesaff.extract_patches">[docs]</a><span class="k">def</span> <span class="nf">extract_patches</span><span class="p">(</span><span class="n">img_or_fpath</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract patches used to compute SIFT descriptors.</span>

<span class="sd">    Args:</span>
<span class="sd">        img_or_fpath (ndarray or str):</span>
<span class="sd">        kpts (ndarray[float32_t, ndim=2]):  keypoints</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m pyhesaff extract_patches:0 --show</span>
<span class="sd">        python -m pyhesaff extract_vecs:1 --fname=astro.png</span>
<span class="sd">        python -m pyhesaff extract_vecs:1 --fname=patsy.jpg --show</span>
<span class="sd">        python -m pyhesaff extract_vecs:1 --fname=carl.jpg</span>
<span class="sd">        python -m pyhesaff extract_vecs:1 --fname=zebra.png</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from pyhesaff._pyhesaff import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import vtool as vt</span>
<span class="sd">        &gt;&gt;&gt; kwargs = {}</span>
<span class="sd">        &gt;&gt;&gt; img_fpath = grab_test_imgpath(&#39;carl.jpg&#39;)</span>
<span class="sd">        &gt;&gt;&gt; img = vt.imread(img_fpath)</span>
<span class="sd">        &gt;&gt;&gt; img_or_fpath = img</span>
<span class="sd">        &gt;&gt;&gt; kpts, vecs1 = detect_feats(img_fpath)</span>
<span class="sd">        &gt;&gt;&gt; kpts = kpts[1::len(kpts) // 9]</span>
<span class="sd">        &gt;&gt;&gt; vecs1 = vecs1[1::len(vecs1) // 9]</span>
<span class="sd">        &gt;&gt;&gt; cpp_patch_list = extract_patches(img, kpts)</span>
<span class="sd">        &gt;&gt;&gt; py_patch_list_ = np.array(vt.get_warped_patches(img_or_fpath, kpts, patch_size=41)[0])</span>
<span class="sd">        &gt;&gt;&gt; py_patch_list = np.array(vt.convert_image_list_colorspace(py_patch_list_, &#39;gray&#39;))</span>
<span class="sd">        &gt;&gt;&gt; # xdoctest: +REQUIRES(--show)</span>
<span class="sd">        &gt;&gt;&gt; import plottool as pt</span>
<span class="sd">        &gt;&gt;&gt; ax = pt.draw_patches_and_sifts(cpp_patch_list, None, pnum=(1, 2, 1))</span>
<span class="sd">        &gt;&gt;&gt; ax.set_title(&#39;C++ extracted&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ax = pt.draw_patches_and_sifts(py_patch_list, None, pnum=(1, 2, 2))</span>
<span class="sd">        &gt;&gt;&gt; ax.set_title(&#39;Python extracted&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pt.show_if_requested()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img_or_fpath</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="n">hesaff_ptr</span> <span class="o">=</span> <span class="n">_new_fpath_hesaff</span><span class="p">(</span><span class="n">img_or_fpath</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hesaff_ptr</span> <span class="o">=</span> <span class="n">_new_image_hesaff</span><span class="p">(</span><span class="n">img_or_fpath</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">nKpts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kpts</span><span class="p">)</span>
    <span class="n">patch_list</span> <span class="o">=</span> <span class="n">alloc_patches</span><span class="p">(</span><span class="n">nKpts</span><span class="p">,</span> <span class="mi">41</span><span class="p">)</span>  <span class="c1"># allocate memory for patches</span>
    <span class="n">patch_list</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">kpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">kpts</span><span class="p">)</span>  <span class="c1"># kpts might not be contiguous</span>
    <span class="c1"># extract decsriptors at given locations</span>
    <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">extractPatches</span><span class="p">(</span><span class="n">hesaff_ptr</span><span class="p">,</span> <span class="n">nKpts</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">patch_list</span><span class="p">)</span>
    <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">free_hesaff</span><span class="p">(</span><span class="n">hesaff_ptr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">patch_list</span></div>


<div class="viewcode-block" id="extract_desc_from_patches"><a class="viewcode-back" href="../../pyhesaff.html#pyhesaff._pyhesaff.extract_desc_from_patches">[docs]</a><span class="k">def</span> <span class="nf">extract_desc_from_patches</span><span class="p">(</span><span class="n">patch_list</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Careful about the way the patches are extracted here.</span>

<span class="sd">    Args:</span>
<span class="sd">        patch_list (ndarray[ndims=3]):</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m pyhesaff extract_desc_from_patches  --rebuild-hesaff --no-rmbuild</span>
<span class="sd">        python -m pyhesaff extract_desc_from_patches  --rebuild-hesaff --no-rmbuild --show</span>
<span class="sd">        python -m pyhesaff extract_desc_from_patches:1 --show</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from pyhesaff._pyhesaff import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import vtool as vt</span>
<span class="sd">        &gt;&gt;&gt; img_fpath = grab_test_imgpath(ub.argval(&#39;--fname&#39;, default=&#39;astro.png&#39;))</span>
<span class="sd">        &gt;&gt;&gt; # First extract keypoints normally</span>
<span class="sd">        &gt;&gt;&gt; (orig_kpts_list, orig_vecs_list) = detect_feats(img_fpath)</span>
<span class="sd">        &gt;&gt;&gt; # Take 9 keypoints</span>
<span class="sd">        &gt;&gt;&gt; img = vt.imread(img_fpath)</span>
<span class="sd">        &gt;&gt;&gt; kpts_list = orig_kpts_list[1::len(orig_kpts_list) // 9]</span>
<span class="sd">        &gt;&gt;&gt; vecs_list = orig_vecs_list[1::len(orig_vecs_list) // 9]</span>
<span class="sd">        &gt;&gt;&gt; # Extract the underlying grayscale patches (using different patch_size)</span>
<span class="sd">        &gt;&gt;&gt; patch_list_ = np.array(vt.get_warped_patches(img, kpts_list, patch_size=64)[0])</span>
<span class="sd">        &gt;&gt;&gt; patch_list = np.array(vt.convert_image_list_colorspace(patch_list_, &#39;gray&#39;))</span>
<span class="sd">        &gt;&gt;&gt; # Extract descriptors from the patches</span>
<span class="sd">        &gt;&gt;&gt; vecs_array = extract_desc_from_patches(patch_list)</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from pyhesaff._pyhesaff import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import vtool as vt</span>
<span class="sd">        &gt;&gt;&gt; img_fpath = grab_test_imgpath(ub.argval(&#39;--fname&#39;, default=&#39;astro.png&#39;))</span>
<span class="sd">        &gt;&gt;&gt; # First extract keypoints normally</span>
<span class="sd">        &gt;&gt;&gt; (orig_kpts_list, orig_vecs_list) = detect_feats(img_fpath)</span>
<span class="sd">        &gt;&gt;&gt; # Take 9 keypoints</span>
<span class="sd">        &gt;&gt;&gt; img = vt.imread(img_fpath)</span>
<span class="sd">        &gt;&gt;&gt; kpts_list = orig_kpts_list[1::len(orig_kpts_list) // 9]</span>
<span class="sd">        &gt;&gt;&gt; vecs_list = orig_vecs_list[1::len(orig_vecs_list) // 9]</span>
<span class="sd">        &gt;&gt;&gt; # Extract the underlying grayscale patches</span>
<span class="sd">        &gt;&gt;&gt; #patch_list_ = np.array(vt.get_warped_patches(img, kpts_list)[0])</span>
<span class="sd">        &gt;&gt;&gt; #patch_list = np.array(vt.convert_image_list_colorspace(patch_list_, &#39;gray&#39;))</span>
<span class="sd">        &gt;&gt;&gt; patch_list = extract_patches(img, kpts_list)</span>
<span class="sd">        &gt;&gt;&gt; patch_list = np.round(patch_list).astype(np.uint8)</span>
<span class="sd">        &gt;&gt;&gt; # Currently its impossible to get the correct answer</span>
<span class="sd">        &gt;&gt;&gt; # TODO: allow patches to be passed in as float32</span>
<span class="sd">        &gt;&gt;&gt; # Extract descriptors from those patches</span>
<span class="sd">        &gt;&gt;&gt; vecs_array = extract_desc_from_patches(patch_list)</span>
<span class="sd">        &gt;&gt;&gt; # Comparse to see if they are close to the original descriptors</span>
<span class="sd">        &gt;&gt;&gt; errors = vt.L2_sift(vecs_list, vecs_array)</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;Errors: %r&#39; % (errors,))</span>
<span class="sd">        &gt;&gt;&gt; # xdoctest: +REQUIRES(--show)</span>
<span class="sd">        &gt;&gt;&gt; import plottool as pt</span>
<span class="sd">        &gt;&gt;&gt; ax = pt.draw_patches_and_sifts(patch_list, vecs_array, pnum=(1, 2, 1))</span>
<span class="sd">        &gt;&gt;&gt; ax.set_title(&#39;patch extracted&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ax = pt.draw_patches_and_sifts(patch_list, vecs_list, pnum=(1, 2, 2))</span>
<span class="sd">        &gt;&gt;&gt; ax.set_title(&#39;image extracted&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pt.show_if_requested()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ndims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">patch_list</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ndims</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="n">patch_list</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[pyhesaff] warning need to reshape patch_list&#39;</span><span class="p">)</span>
        <span class="c1"># need to remove grayscale dimension, maybe it should be included</span>
        <span class="n">patch_list</span> <span class="o">=</span> <span class="n">patch_list</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">patch_list</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">ndims</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="n">patch_list</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;cannot handle color images yet&#39;</span>
    <span class="k">assert</span> <span class="n">patch_list</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;C_CONTIGUOUS&#39;</span><span class="p">],</span> <span class="s1">&#39;patch_list must be contiguous array&#39;</span>
    <span class="n">num_patches</span><span class="p">,</span> <span class="n">patch_h</span><span class="p">,</span> <span class="n">patch_w</span> <span class="o">=</span> <span class="n">patch_list</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">patch_h</span> <span class="o">==</span> <span class="n">patch_w</span><span class="p">,</span> <span class="s1">&#39;must be square patches&#39;</span>
    <span class="n">vecs_array</span> <span class="o">=</span> <span class="n">alloc_vecs</span><span class="p">(</span><span class="n">num_patches</span><span class="p">)</span>
    <span class="c1"># vecs_array[:] = 0</span>
    <span class="c1"># print(&#39;vecs_array = %r&#39; % (vecs_array,))</span>
    <span class="c1"># If the input array list is memmaped it is a good idea to process in chunks</span>
    <span class="n">CHUNKS</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">patch_list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">CHUNKS</span><span class="p">:</span>
        <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">extractDescFromPatches</span><span class="p">(</span>
            <span class="n">num_patches</span><span class="p">,</span> <span class="n">patch_h</span><span class="p">,</span> <span class="n">patch_w</span><span class="p">,</span> <span class="n">patch_list</span><span class="p">,</span> <span class="n">vecs_array</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">chunksize</span> <span class="o">=</span> <span class="mi">2048</span>
        <span class="n">_iter</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_patches</span> <span class="o">//</span> <span class="n">chunksize</span><span class="p">)</span>
        <span class="n">_progiter</span> <span class="o">=</span> <span class="n">ub</span><span class="o">.</span><span class="n">ProgIter</span><span class="p">(</span><span class="n">_iter</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;extracting sift chunk&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="n">_progiter</span><span class="p">:</span>
            <span class="n">lx</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">*</span> <span class="n">chunksize</span>
            <span class="n">rx</span> <span class="o">=</span> <span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">chunksize</span>
            <span class="n">patch_sublist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">patch_list</span><span class="p">[</span><span class="n">lx</span><span class="p">:</span><span class="n">rx</span><span class="p">])</span>
            <span class="n">sublist_size</span> <span class="o">=</span> <span class="n">rx</span> <span class="o">-</span> <span class="n">lx</span>
            <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">extractDescFromPatches</span><span class="p">(</span>
                <span class="n">sublist_size</span><span class="p">,</span> <span class="n">patch_h</span><span class="p">,</span> <span class="n">patch_w</span><span class="p">,</span> <span class="n">patch_sublist</span><span class="p">,</span> <span class="n">vecs_array</span><span class="p">[</span><span class="n">lx</span><span class="p">:</span><span class="n">rx</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="n">last_size</span> <span class="o">=</span> <span class="n">num_patches</span> <span class="o">-</span> <span class="n">rx</span>
        <span class="k">if</span> <span class="n">last_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lx</span> <span class="o">=</span> <span class="n">rx</span>
            <span class="n">rx</span> <span class="o">=</span> <span class="n">lx</span> <span class="o">+</span> <span class="n">last_size</span>
            <span class="n">patch_sublist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">patch_list</span><span class="p">[</span><span class="n">lx</span><span class="p">:</span><span class="n">rx</span><span class="p">])</span>
            <span class="n">sublist_size</span> <span class="o">=</span> <span class="n">rx</span> <span class="o">-</span> <span class="n">lx</span>
            <span class="n">HESAFF_CLIB</span><span class="o">.</span><span class="n">extractDescFromPatches</span><span class="p">(</span>
                <span class="n">sublist_size</span><span class="p">,</span> <span class="n">patch_h</span><span class="p">,</span> <span class="n">patch_w</span><span class="p">,</span> <span class="n">patch_sublist</span><span class="p">,</span> <span class="n">vecs_array</span><span class="p">[</span><span class="n">lx</span><span class="p">:</span><span class="n">rx</span><span class="p">]</span>
            <span class="p">)</span>
    <span class="c1"># print(&#39;vecs_array = %r&#39; % (vecs_array,))</span>
    <span class="k">return</span> <span class="n">vecs_array</span></div>


<span class="c1"># ============================</span>
<span class="c1"># other</span>
<span class="c1"># ============================</span>


<div class="viewcode-block" id="test_rot_invar"><a class="viewcode-back" href="../../pyhesaff.html#pyhesaff._pyhesaff.test_rot_invar">[docs]</a><span class="k">def</span> <span class="nf">test_rot_invar</span><span class="p">():</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CommandLine:</span>
<span class="sd">        python -m pyhesaff test_rot_invar --show --rebuild-hesaff --no-rmbuild</span>
<span class="sd">        python -m pyhesaff test_rot_invar --show --nocpp</span>

<span class="sd">        python -m vtool.tests.demodata testdata_ratio_matches --show --ratio_thresh=1.0 --rotation_invariance --rebuild-hesaff</span>
<span class="sd">        python -m vtool.tests.demodata testdata_ratio_matches --show --ratio_thresh=1.1 --rotation_invariance --rebuild-hesaff</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DODCTEST</span>
<span class="sd">        &gt;&gt;&gt; from pyhesaff._pyhesaff import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; test_rot_invar()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">cv2</span>
    <span class="kn">import</span> <span class="nn">vtool</span> <span class="k">as</span> <span class="nn">vt</span>
    <span class="kn">import</span> <span class="nn">plottool</span> <span class="k">as</span> <span class="nn">pt</span>

    <span class="n">TAU</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">fnum</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">next_fnum</span><span class="p">()</span>
    <span class="n">NUM_PTS</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># 9</span>
    <span class="n">theta_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">TAU</span><span class="p">,</span> <span class="n">NUM_PTS</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">nRows</span><span class="p">,</span> <span class="n">nCols</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">get_square_row_cols</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">theta_list</span><span class="p">),</span> <span class="n">fix</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">next_pnum</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">make_pnum_nextgen</span><span class="p">(</span><span class="n">nRows</span><span class="p">,</span> <span class="n">nCols</span><span class="p">)</span>
    <span class="c1"># Expand the border a bit around star.png</span>
    <span class="n">pad_</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">img_fpath</span> <span class="o">=</span> <span class="n">grab_test_imgpath</span><span class="p">(</span><span class="s1">&#39;star.png&#39;</span><span class="p">)</span>
    <span class="n">img_fpath2</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">pad_image_ondisk</span><span class="p">(</span><span class="n">img_fpath</span><span class="p">,</span> <span class="n">pad_</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">26</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">theta_list</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-----------------&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;theta = </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,))</span>
        <span class="n">img_fpath</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">rotate_image_ondisk</span><span class="p">(</span>
            <span class="n">img_fpath2</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">border_mode</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_REPLICATE</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ub</span><span class="o">.</span><span class="n">argflag</span><span class="p">(</span><span class="s1">&#39;--nocpp&#39;</span><span class="p">):</span>
            <span class="p">(</span><span class="n">kpts_list_ri</span><span class="p">,</span> <span class="n">vecs_list2</span><span class="p">)</span> <span class="o">=</span> <span class="n">detect_feats</span><span class="p">(</span><span class="n">img_fpath</span><span class="p">,</span> <span class="n">rotation_invariance</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">kpts_ri</span> <span class="o">=</span> <span class="n">kpts_list_ri</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="p">(</span><span class="n">kpts_list_gv</span><span class="p">,</span> <span class="n">vecs_list1</span><span class="p">)</span> <span class="o">=</span> <span class="n">detect_feats</span><span class="p">(</span><span class="n">img_fpath</span><span class="p">,</span> <span class="n">rotation_invariance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">kpts_gv</span> <span class="o">=</span> <span class="n">kpts_list_gv</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1"># find_kpts_direction</span>
        <span class="n">imgBGR</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">img_fpath</span><span class="p">)</span>
        <span class="n">kpts_ripy</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">find_kpts_direction</span><span class="p">(</span><span class="n">imgBGR</span><span class="p">,</span> <span class="n">kpts_gv</span><span class="p">,</span> <span class="n">DEBUG_ROTINVAR</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Verify results stdout</span>
        <span class="c1"># print(&#39;nkpts = %r&#39; % (len(kpts_gv)))</span>
        <span class="c1"># print(vt.kpts_repr(kpts_gv))</span>
        <span class="c1"># print(vt.kpts_repr(kpts_ri))</span>
        <span class="c1"># print(vt.kpts_repr(kpts_ripy))</span>
        <span class="c1"># Verify results plot</span>
        <span class="n">pt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">fnum</span><span class="o">=</span><span class="n">fnum</span><span class="p">,</span> <span class="n">pnum</span><span class="o">=</span><span class="n">next_pnum</span><span class="p">())</span>
        <span class="n">pt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgBGR</span><span class="p">)</span>
        <span class="c1"># if len(kpts_gv) &gt; 0:</span>
        <span class="c1">#    pt.draw_kpts2(kpts_gv, ori=True, ell_color=pt.BLUE, ell_linewidth=10.5)</span>
        <span class="n">ell</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">rect</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ub</span><span class="o">.</span><span class="n">argflag</span><span class="p">(</span><span class="s1">&#39;--nocpp&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kpts_ri</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">pt</span><span class="o">.</span><span class="n">draw_kpts2</span><span class="p">(</span>
                    <span class="n">kpts_ri</span><span class="p">,</span>
                    <span class="n">rect</span><span class="o">=</span><span class="n">rect</span><span class="p">,</span>
                    <span class="n">ell</span><span class="o">=</span><span class="n">ell</span><span class="p">,</span>
                    <span class="n">ori</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">ell_color</span><span class="o">=</span><span class="n">pt</span><span class="o">.</span><span class="n">RED</span><span class="p">,</span>
                    <span class="n">ell_linewidth</span><span class="o">=</span><span class="mf">5.5</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kpts_ripy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pt</span><span class="o">.</span><span class="n">draw_kpts2</span><span class="p">(</span>
                <span class="n">kpts_ripy</span><span class="p">,</span>
                <span class="n">rect</span><span class="o">=</span><span class="n">rect</span><span class="p">,</span>
                <span class="n">ell</span><span class="o">=</span><span class="n">ell</span><span class="p">,</span>
                <span class="n">ori</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">ell_color</span><span class="o">=</span><span class="n">pt</span><span class="o">.</span><span class="n">GREEN</span><span class="p">,</span>
                <span class="n">ell_linewidth</span><span class="o">=</span><span class="mf">3.5</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="n">pt</span><span class="o">.</span><span class="n">set_figtitle</span><span class="p">(</span><span class="s1">&#39;green=python, red=C++&#39;</span><span class="p">)</span>
    <span class="n">pt</span><span class="o">.</span><span class="n">show_if_requested</span><span class="p">()</span></div>


<div class="viewcode-block" id="vtool_adapt_rotation"><a class="viewcode-back" href="../../pyhesaff.html#pyhesaff._pyhesaff.vtool_adapt_rotation">[docs]</a><span class="k">def</span> <span class="nf">vtool_adapt_rotation</span><span class="p">(</span><span class="n">img_fpath</span><span class="p">,</span> <span class="n">kpts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; rotation invariance in python &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">vtool.patch</span> <span class="k">as</span> <span class="nn">ptool</span>
    <span class="kn">import</span> <span class="nn">vtool.image</span> <span class="k">as</span> <span class="nn">gtool</span>

    <span class="n">imgBGR</span> <span class="o">=</span> <span class="n">gtool</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">img_fpath</span><span class="p">)</span>
    <span class="n">kpts2</span> <span class="o">=</span> <span class="n">ptool</span><span class="o">.</span><span class="n">find_kpts_direction</span><span class="p">(</span><span class="n">imgBGR</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
    <span class="n">vecs2</span> <span class="o">=</span> <span class="n">extract_vecs</span><span class="p">(</span><span class="n">img_fpath</span><span class="p">,</span> <span class="n">kpts2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kpts2</span><span class="p">,</span> <span class="n">vecs2</span></div>


<div class="viewcode-block" id="adapt_scale"><a class="viewcode-back" href="../../pyhesaff.html#pyhesaff._pyhesaff.adapt_scale">[docs]</a><span class="k">def</span> <span class="nf">adapt_scale</span><span class="p">(</span><span class="n">img_fpath</span><span class="p">,</span> <span class="n">kpts</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">vtool.ellipse</span> <span class="k">as</span> <span class="nn">etool</span>

    <span class="n">nScales</span> <span class="o">=</span> <span class="mi">16</span>
    <span class="n">nSamples</span> <span class="o">=</span> <span class="mi">16</span>
    <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
    <span class="n">kpts2</span> <span class="o">=</span> <span class="n">etool</span><span class="o">.</span><span class="n">adaptive_scale</span><span class="p">(</span><span class="n">img_fpath</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">nScales</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">nSamples</span><span class="p">)</span>
    <span class="c1"># passing in 0 orientation results in gravity vector direction keypoint</span>
    <span class="n">vecs2</span> <span class="o">=</span> <span class="n">extract_vecs</span><span class="p">(</span><span class="n">img_fpath</span><span class="p">,</span> <span class="n">kpts2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kpts2</span><span class="p">,</span> <span class="n">vecs2</span></div>


<span class="c1"># del type_, key, val</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CommandLine:</span>
<span class="sd">        python -m pyhesaff._pyhesaff</span>
<span class="sd">        python -m pyhesaff._pyhesaff --allexamples</span>
<span class="sd">        python -m pyhesaff._pyhesaff --allexamples --noface --nosrc</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">xdoctest</span>

    <span class="n">xdoctest</span><span class="o">.</span><span class="n">doctest_module</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">wbia-pyhesaff</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../pyhesaff.html">pyhesaff package</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Wild Me.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>