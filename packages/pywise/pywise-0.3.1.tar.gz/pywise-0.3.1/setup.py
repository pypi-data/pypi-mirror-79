# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['core_utils']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'pywise',
    'version': '0.3.1',
    'description': 'Robust serialization support for NamedTuple & @dataclass data types.',
    'long_description': '# `pywise`\n[![PyPI version](https://badge.fury.io/py/pywise.svg)](https://badge.fury.io/py/pywise) [![Build Status](https://travis-ci.org/malcolmgreaves/pywise.svg?branch=main)](https://travis-ci.org/malcolmgreaves/pywise) [![Coverage Status](https://coveralls.io/repos/github/malcolmgreaves/pywise/badge.svg?branch=main)](https://coveralls.io/github/malcolmgreaves/pywise?branch=main)\n\nContains functions that provide general utility and build upon the Python 3 standard library. It has no external dependencies.\n  - `serialization`: serialization & deserialization for `NamedTuple`-deriving & `@dataclass` decorated classes\n  - `archives`: uncompress tar archives\n  - `common`: utilities\n  - `schema`: obtain a `dict`-like structure describing the fields & types for any serialzable type (helpful to view as JSON)\n\nThis project\'s most notable functionality are the `serialize` and `deserialize` funtions of `core_utils.serialization`.\nTake a look at the end of this document for example use.\n\n\n\n## Development Setup\nThis project uses [`poetry`](https://python-poetry.org/) for virtualenv and dependency management. We recommend using [`brew`](https://brew.sh/) to install `poetry` system-wide.\n\nTo install the project\'s dependencies, perform:\n```\npoetry install\n```\n\nEvery command must be run within the `poetry`-managed environment.\nFor instance, to open a Python shell, you would execute:\n```\npoetry run python\n```\nAlternatively, you may activate the environment by performing `poetry shell` and directly invoke Python programs.\n\n\n#### Testing\nTo run tests, execute:\n```\npoetry run pytest -v\n```\nTo run tests against all supported environments, use [`tox`](https://tox.readthedocs.io/en/latest/):\n```\npoetry run tox -p\n```\nNOTE: To run `tox`, you must have all necessary Python interpreters available.\n      We recommend using [`pyenv`](https://github.com/pyenv/pyenv) to manage your Python versions.\n\n\n#### Dev Tools\nThis project uses `black` for code formatting, `flake8` for linting, and\n`mypy` for type checking. Use the following commands to ensure code quality:\n```\n# formats all code in-place\nblack .\n\n# typechecks\nmypy --ignore-missing-imports --follow-imports=silent --show-column-numbers --warn-unreachable .\n\n# lints code\nflake8 --max-line-length=100 --ignore=E501,W293,E303,W291,W503,E203,E731,E231,E721,E722,E741 .\n```\n\n\n## Documentation via Examples\n\n#### Nested @dataclass and NamedTuple\nLets say you have an address book that you want to write to and from JSON.\nWe\'ll define our data types for our `AddressBook`:\n\n```python\nfrom typing import Optional, Union, Sequence\nfrom dataclasses import dataclass\nfrom enum import Enum, auto\n\n@dataclass(frozen=True)\nclass Name:\n    first: str\n    last: str\n    middle: Optional[str] = None\n\nclass PhoneNumber(NamedTuple):\n    area_code: int\n    number: int\n    extension: Optional[int] = None\n\n@dataclass(frozen=True)\nclass EmailAddress:\n    name: str\n    domain: str\n\nclass ContactType(Enum):\n    personal, professional = auto(), auto()\n\nclass Emergency(NamedTuple):\n    full_name: str\n    contact: Union[PhoneNumber, EmailAddress]\n\n@dataclass(frozen=True)\nclass Entry:\n    name: Name\n    number: PhoneNumber\n    email: EmailAddress\n    contact_type: ContactType\n    emergency_contact: Emergency\n\n@dataclass(frozen=True)\nclass AddressBook:\n    entries: Sequence[Entry]\n```\n\nFor illustration, let\'s consider the following instantiated `AddressBook`:\n```python\nab = AddressBook([\n    Entry(Name(\'Malcolm\', \'Greaves\', middle=\'W\'), \n          PhoneNumber(510,3452113),\n          EmailAddress(\'malcolm\',\'world.com\'),\n          contact_type=ContactType.professional,\n          emergency_contact=Emergency("Superman", PhoneNumber(262,1249865,extension=1))\n    ),\n])\n```\n\nWe can convert our `AddressBook` data type into a JSON-formatted string using `serialize`:\n```python\nfrom core_utils.serialization import serialize\nimport json\n\ns = serialize(ab)\nj = json.dumps(s, indent=2)\nprint(j)\n```\n\nAnd we can easily convert the JSON string back into a new instanitated `AddressBook` using `deserialize`:\n```python\nfrom core_utils.serialization import deserialize\n\nd = json.loads(j)\nnew_ab = deserialize(AddressBook, d)\nprint(ab == new_ab)\n# NOTE: The @dataclass(frozen=True) is only needed to make this equality work.\n#       Any @dataclass decorated type is serializable. \n```\n\nNote that the `deserialize` function needs the type to deserialize the data into. The deserizliation\ntype-matching is _structural_: it will work so long as the data type\'s structure (of field names and\nassociated types) is compatible with the supplied data.\n\n\n#### Custom Serialization\nIn the event that one desires to use `serialize` and `deserialize` with data types from third-party libraries (e.g. `numpy` arrays) or custom-defined `class`es that are not decorated with `@dataclass` or derive from `NamedTuple`, one may supply a `CustomFormat`.\n\n`CustomFormat` is a mapping that associates precise types with custom serialization functions. When supplied to `serialize`, the values in the mapping accept an instance of the exact type and produces a serializable representation. In the `deserialize` function, they convert such a serialized representation into a bonafide instance of the type.\n\nTo illustrate their use, we\'ll deine `CustomFormat` `dict`s that allow us to serialize `numpy` multi-dimensional arrays:\n```python\nimport numpy as np\nfrom core_utils.serialization import *\n\n\ncustom_serialization: CustomFormat = {\n    np.ndarray: lambda arr: arr.tolist()\n}\n\ncustom_deserialization: CustomFormat = {\n    np.ndarray: lambda lst: np.array(lst)\n}\n```\n\nNow, we may supply `custom_{serialization,deserialization}` to our functions. We\'ll use them to perform a "round-trip" serialization of a four-dimensional array of floating point numbers to and from a JSON-formatted `str`:\n```python\nimport json\n\nv_original = np.random.random((1,2,3,4))\ns = serialize(v_original, custom=custom_serialization)\nj = json.dumps(s)\n\nd = json.loads(j)\nv_deser = deserialize(np.ndarray, d, custom=custom_deserialization)\n\nprint((v_original == v_deser).all())\n```\n\nIt\'s important to note that, when supplying a `CustomFormat` the serialization functions take priority over the default behavior (except for `Any`, as it is _always_ considered a pass-through). Moreover, types must match **exactly** to the keys in the mapping. Thus, if using a generic type, you must supply separate key-value entires for each distinct type parameterization.\n\n',
    'author': 'Malcolm Greaves',
    'author_email': 'greaves.malcolm@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/malcolmgreaves/pywise',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
