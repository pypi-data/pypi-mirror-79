import hal.simulation._simulation
import typing
import hal._wpiHal

__all__ = [
    "AccelerometerSim",
    "AnalogGyroSim",
    "AnalogInSim",
    "AnalogOutSim",
    "AnalogTriggerSim",
    "CallbackStore",
    "DIOSim",
    "DigitalPWMSim",
    "DriverStationSim",
    "DutyCycleSim",
    "EncoderSim",
    "PCMSim",
    "PDPSim",
    "PWMSim",
    "RelaySim",
    "RoboRioSim",
    "SPIAccelerometerSim",
    "SimDeviceSim",
    "getProgramStarted",
    "restartTiming",
    "setProgramStarted",
    "waitForProgramStart"
]


class AccelerometerSim():
    def __init__(self, index: int) -> None: ...
    def getActive(self) -> bool: ...
    def getRange(self) -> hal._wpiHal.AccelerometerRange: ...
    def getX(self) -> float: ...
    def getY(self) -> float: ...
    def getZ(self) -> float: ...
    def registerActiveCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerRangeCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerXCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerYCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerZCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def resetData(self) -> None: ...
    def setActive(self, active: bool) -> None: ...
    def setRange(self, range: hal._wpiHal.AccelerometerRange) -> None: ...
    def setX(self, x: float) -> None: ...
    def setY(self, y: float) -> None: ...
    def setZ(self, z: float) -> None: ...
    pass
class AnalogGyroSim():
    def __init__(self, index: int) -> None: ...
    def getAngle(self) -> float: ...
    def getInitialized(self) -> bool: ...
    def getRate(self) -> float: ...
    def registerAngleCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerInitializedCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerRateCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def resetData(self) -> None: ...
    def setAngle(self, angle: float) -> None: ...
    def setInitialized(self, initialized: bool) -> None: ...
    def setRate(self, rate: float) -> None: ...
    pass
class AnalogInSim():
    def __init__(self, index: int) -> None: ...
    def getAccumulatorCenter(self) -> int: ...
    def getAccumulatorCount(self) -> int: ...
    def getAccumulatorDeadband(self) -> int: ...
    def getAccumulatorInitialized(self) -> bool: ...
    def getAccumulatorValue(self) -> int: ...
    def getAverageBits(self) -> int: ...
    def getInitialized(self) -> bool: ...
    def getOversampleBits(self) -> int: ...
    def getVoltage(self) -> float: ...
    def registerAccumulatorCenterCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerAccumulatorCountCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerAccumulatorDeadbandCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerAccumulatorInitializedCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerAccumulatorValueCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerAverageBitsCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerInitializedCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerOversampleBitsCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerVoltageCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def resetData(self) -> None: ...
    def setAccumulatorCenter(self, accumulatorCenter: int) -> None: ...
    def setAccumulatorCount(self, accumulatorCount: int) -> None: ...
    def setAccumulatorDeadband(self, accumulatorDeadband: int) -> None: ...
    def setAccumulatorInitialized(self, accumulatorInitialized: bool) -> None: ...
    def setAccumulatorValue(self, accumulatorValue: int) -> None: ...
    def setAverageBits(self, averageBits: int) -> None: ...
    def setInitialized(self, initialized: bool) -> None: ...
    def setOversampleBits(self, oversampleBits: int) -> None: ...
    def setVoltage(self, voltage: float) -> None: ...
    pass
class AnalogOutSim():
    def __init__(self, index: int) -> None: ...
    def getInitialized(self) -> bool: ...
    def getVoltage(self) -> float: ...
    def registerInitializedCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerVoltageCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def resetData(self) -> None: ...
    def setInitialized(self, initialized: bool) -> None: ...
    def setVoltage(self, voltage: float) -> None: ...
    pass
class AnalogTriggerSim():
    def __init__(self, index: int) -> None: ...
    def getInitialized(self) -> bool: ...
    def getTriggerLowerBound(self) -> float: ...
    def getTriggerUpperBound(self) -> float: ...
    def registerInitializedCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerTriggerLowerBoundCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerTriggerUpperBoundCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def resetData(self) -> None: ...
    def setInitialized(self, initialized: bool) -> None: ...
    def setTriggerLowerBound(self, triggerLowerBound: float) -> None: ...
    def setTriggerUpperBound(self, triggerUpperBound: float) -> None: ...
    pass
class CallbackStore():
    def setUid(self, uid: int) -> None: ...
    pass
class DIOSim():
    def __init__(self, index: int) -> None: ...
    def getFilterIndex(self) -> int: ...
    def getInitialized(self) -> bool: ...
    def getIsInput(self) -> bool: ...
    def getPulseLength(self) -> float: ...
    def getValue(self) -> bool: ...
    def registerFilterIndexCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerInitializedCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerIsInputCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerPulseLengthCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerValueCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def resetData(self) -> None: ...
    def setFilterIndex(self, filterIndex: int) -> None: ...
    def setInitialized(self, initialized: bool) -> None: ...
    def setIsInput(self, isInput: bool) -> None: ...
    def setPulseLength(self, pulseLength: float) -> None: ...
    def setValue(self, value: bool) -> None: ...
    pass
class DigitalPWMSim():
    def __init__(self, index: int) -> None: ...
    def getDutyCycle(self) -> float: ...
    def getInitialized(self) -> bool: ...
    def getPin(self) -> int: ...
    def registerDutyCycleCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerInitializedCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerPinCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def resetData(self) -> None: ...
    def setDutyCycle(self, dutyCycle: float) -> None: ...
    def setInitialized(self, initialized: bool) -> None: ...
    def setPin(self, pin: int) -> None: ...
    pass
class DriverStationSim():
    def __init__(self) -> None: ...
    def getAutonomous(self) -> bool: ...
    def getDsAttached(self) -> bool: ...
    def getEStop(self) -> bool: ...
    def getEnabled(self) -> bool: ...
    def getFmsAttached(self) -> bool: ...
    def getTest(self) -> bool: ...
    def notifyNewData(self) -> None: ...
    def registerAutonomousCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerDsAttachedCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerEStopCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerEnabledCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerFmsAttachedCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerTestCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def resetData(self) -> None: ...
    def setAutonomous(self, autonomous: bool) -> None: ...
    def setDsAttached(self, dsAttached: bool) -> None: ...
    def setEStop(self, eStop: bool) -> None: ...
    def setEnabled(self, enabled: bool) -> None: ...
    def setFmsAttached(self, fmsAttached: bool) -> None: ...
    def setTest(self, test: bool) -> None: ...
    pass
class DutyCycleSim():
    def __init__(self, index: int) -> None: ...
    def getFrequency(self) -> int: ...
    def getInitialized(self) -> bool: ...
    def getOutput(self) -> float: ...
    def registerFrequencyCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerInitializedCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerOutputCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def resetData(self) -> None: ...
    def setFrequency(self, count: int) -> None: ...
    def setInitialized(self, initialized: bool) -> None: ...
    def setOutput(self, period: float) -> None: ...
    pass
class EncoderSim():
    def __init__(self, index: int) -> None: ...
    def getCount(self) -> int: ...
    def getDirection(self) -> bool: ...
    def getDistancePerPulse(self) -> float: ...
    def getInitialized(self) -> bool: ...
    def getMaxPeriod(self) -> float: ...
    def getPeriod(self) -> float: ...
    def getReset(self) -> bool: ...
    def getReverseDirection(self) -> bool: ...
    def getSamplesToAverage(self) -> int: ...
    def registerCountCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerDirectionCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerDistancePerPulseCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerInitializedCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerMaxPeriodCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerPeriodCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerResetCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerReverseDirectionCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerSamplesToAverageCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def resetData(self) -> None: ...
    def setCount(self, count: int) -> None: ...
    def setDirection(self, direction: bool) -> None: ...
    def setDistancePerPulse(self, distancePerPulse: float) -> None: ...
    def setInitialized(self, initialized: bool) -> None: ...
    def setMaxPeriod(self, maxPeriod: float) -> None: ...
    def setPeriod(self, period: float) -> None: ...
    def setReset(self, reset: bool) -> None: ...
    def setReverseDirection(self, reverseDirection: bool) -> None: ...
    def setSamplesToAverage(self, samplesToAverage: int) -> None: ...
    pass
class PCMSim():
    def __init__(self, index: int) -> None: ...
    def getAllSolenoidOutputs(self) -> int: ...
    def getClosedLoopEnabled(self) -> bool: ...
    def getCompressorCurrent(self) -> float: ...
    def getCompressorInitialized(self) -> bool: ...
    def getCompressorOn(self) -> bool: ...
    def getPressureSwitch(self) -> bool: ...
    def getSolenoidInitialized(self, channel: int) -> bool: ...
    def getSolenoidOutput(self, channel: int) -> bool: ...
    def registerClosedLoopEnabledCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerCompressorCurrentCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerCompressorInitializedCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerCompressorOnCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerPressureSwitchCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerSolenoidInitializedCallback(self, channel: int, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerSolenoidOutputCallback(self, channel: int, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def resetData(self) -> None: ...
    def setAllSolenoidOutputs(self, outputs: int) -> None: ...
    def setClosedLoopEnabled(self, closedLoopEnabled: bool) -> None: ...
    def setCompressorCurrent(self, compressorCurrent: float) -> None: ...
    def setCompressorInitialized(self, compressorInitialized: bool) -> None: ...
    def setCompressorOn(self, compressorOn: bool) -> None: ...
    def setPressureSwitch(self, pressureSwitch: bool) -> None: ...
    def setSolenoidInitialized(self, channel: int, solenoidInitialized: bool) -> None: ...
    def setSolenoidOutput(self, channel: int, solenoidOutput: bool) -> None: ...
    pass
class PDPSim():
    def __init__(self, index: int) -> None: ...
    def getAllCurrents(self) -> float: ...
    def getCurrent(self, channel: int) -> float: ...
    def getInitialized(self) -> bool: ...
    def getTemperature(self) -> float: ...
    def getVoltage(self) -> float: ...
    def registerCurrentCallback(self, channel: int, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerInitializedCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerTemperatureCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerVoltageCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def resetData(self) -> None: ...
    def setAllCurrents(self, currents: float) -> None: ...
    def setCurrent(self, channel: int, current: float) -> None: ...
    def setInitialized(self, initialized: bool) -> None: ...
    def setTemperature(self, temperature: float) -> None: ...
    def setVoltage(self, voltage: float) -> None: ...
    pass
class PWMSim():
    def __init__(self, index: int) -> None: ...
    def getInitialized(self) -> bool: ...
    def getPeriodScale(self) -> int: ...
    def getPosition(self) -> float: ...
    def getRawValue(self) -> int: ...
    def getSpeed(self) -> float: ...
    def getZeroLatch(self) -> bool: ...
    def registerInitializedCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerPeriodScaleCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerPositionCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerRawValueCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerSpeedCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerZeroLatchCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def resetData(self) -> None: ...
    def setInitialized(self, initialized: bool) -> None: ...
    def setPeriodScale(self, periodScale: int) -> None: ...
    def setPosition(self, position: float) -> None: ...
    def setRawValue(self, rawValue: int) -> None: ...
    def setSpeed(self, speed: float) -> None: ...
    def setZeroLatch(self, zeroLatch: bool) -> None: ...
    pass
class RelaySim():
    def __init__(self, index: int) -> None: ...
    def getForward(self) -> bool: ...
    def getInitializedForward(self) -> bool: ...
    def getInitializedReverse(self) -> bool: ...
    def getReverse(self) -> bool: ...
    def registerForwardCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerInitializedForwardCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerInitializedReverseCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerReverseCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def resetData(self) -> None: ...
    def setForward(self, forward: bool) -> None: ...
    def setInitializedForward(self, initializedForward: bool) -> None: ...
    def setInitializedReverse(self, initializedReverse: bool) -> None: ...
    def setReverse(self, reverse: bool) -> None: ...
    pass
class RoboRioSim():
    def __init__(self, index: int) -> None: ...
    def getFPGAButton(self) -> bool: ...
    def getUserActive3V3(self) -> bool: ...
    def getUserActive5V(self) -> bool: ...
    def getUserActive6V(self) -> bool: ...
    def getUserCurrent3V3(self) -> float: ...
    def getUserCurrent5V(self) -> float: ...
    def getUserCurrent6V(self) -> float: ...
    def getUserFaults3V3(self) -> int: ...
    def getUserFaults5V(self) -> int: ...
    def getUserFaults6V(self) -> int: ...
    def getUserVoltage3V3(self) -> float: ...
    def getUserVoltage5V(self) -> float: ...
    def getUserVoltage6V(self) -> float: ...
    def getVInCurrent(self) -> float: ...
    def getVInVoltage(self) -> float: ...
    def registerFPGAButtonCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerUserActive3V3Callback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerUserActive5VCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerUserActive6VCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerUserCurrent3V3Callback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerUserCurrent5VCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerUserCurrent6VCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerUserFaults3V3Callback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerUserFaults5VCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerUserFaults6VCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerUserVoltage3V3Callback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerUserVoltage5VCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerUserVoltage6VCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerVInCurrentCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerVInVoltageCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def resetData(self) -> None: ...
    def setFPGAButton(self, fPGAButton: bool) -> None: ...
    def setUserActive3V3(self, userActive3V3: bool) -> None: ...
    def setUserActive5V(self, userActive5V: bool) -> None: ...
    def setUserActive6V(self, userActive6V: bool) -> None: ...
    def setUserCurrent3V3(self, userCurrent3V3: float) -> None: ...
    def setUserCurrent5V(self, userCurrent5V: float) -> None: ...
    def setUserCurrent6V(self, userCurrent6V: float) -> None: ...
    def setUserFaults3V3(self, userFaults3V3: int) -> None: ...
    def setUserFaults5V(self, userFaults5V: int) -> None: ...
    def setUserFaults6V(self, userFaults6V: int) -> None: ...
    def setUserVoltage3V3(self, userVoltage3V3: float) -> None: ...
    def setUserVoltage5V(self, userVoltage5V: float) -> None: ...
    def setUserVoltage6V(self, userVoltage6V: float) -> None: ...
    def setVInCurrent(self, vInCurrent: float) -> None: ...
    def setVInVoltage(self, vInVoltage: float) -> None: ...
    pass
class SPIAccelerometerSim():
    def __init__(self, index: int) -> None: ...
    def getActive(self) -> bool: ...
    def getRange(self) -> int: ...
    def getX(self) -> float: ...
    def getY(self) -> float: ...
    def getZ(self) -> float: ...
    def registerActiveCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerRangeCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerXCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerYCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def registerZCallback(self, callback: typing.Callable[[str, HAL_Value], None], initialNotify: bool) -> CallbackStore: ...
    def resetData(self) -> None: ...
    def setActive(self, active: bool) -> None: ...
    def setRange(self, range: int) -> None: ...
    def setX(self, x: float) -> None: ...
    def setY(self, y: float) -> None: ...
    def setZ(self, z: float) -> None: ...
    pass
class SimDeviceSim():
    """
    Interact with a generic simulated device

    Any devices that support simulation but don't have a dedicated sim
    object associated with it can be interacted with via this object.
    You just need to know the name of the associated object.

    Here are two ways to find the names of available devices:

    * The static function :meth:`.enumerateDevices` can give you a list of
      all available devices -- note that the device must be created first
      before this will return any results!
    * When running the WPILib simulation GUI, the names of the 'Other Devices'
      panel are names of devices that you can interact with via this class.

    Once you've created a simulated device, you can use the :meth:`.enumerateValues`
    method to determine what values you can interact with.


    .. note:: WPILib has simulation support for all of its devices. Some
              vendors may only have limited support for simulation -- read
              the vendor's documentation or contact them for more information.
    """
    def __init__(self, name: str) -> None: ...
    @staticmethod
    def enumerateDevices(prefix: str = '') -> typing.List[str]: 
        """
        Returns a list of available device names
        """
    def enumerateValues(self) -> typing.List[typing.Tuple[str, bool]]: 
        """
        Returns a list of (name, readonly) tuples of available values for this device
        """
    def getBoolean(self, name: str) -> hal._wpiHal.SimBoolean: 
        """
        Retrieves an object that allows you to interact with simulated values
        represented as a boolean.
        """
    def getDouble(self, name: str) -> hal._wpiHal.SimDouble: 
        """
        Retrieves an object that allows you to interact with simulated values
        represented as a double.
        """
    def getEnum(self, name: str) -> hal._wpiHal.SimEnum: ...
    @staticmethod
    def getEnumOptions(val: hal._wpiHal.SimEnum) -> typing.List[str]: ...
    def getValue(self, name: str) -> hal._wpiHal.SimValue: 
        """
        Provides a readonly mechanism to retrieve all types of device values
        """
    @staticmethod
    def resetData() -> None: ...
    pass
def getProgramStarted() -> bool:
    pass
def restartTiming() -> None:
    pass
def setProgramStarted() -> None:
    pass
def waitForProgramStart() -> None:
    pass
