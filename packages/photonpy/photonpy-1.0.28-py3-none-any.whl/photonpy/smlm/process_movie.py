

import numpy as np
import time
import tqdm
import os

from photonpy import Context, Gaussian, Estimator, Dataset
import photonpy.cpp.spotdetect as spotdetect
from photonpy.cpp.calib import GainOffset_Calib
from photonpy.cpp.calib import GainOffsetImage_Calib
from photonpy.cpp.estim_queue import EstimQueue
from photonpy.cpp.roi_queue import ROIQueue
from photonpy.cpp.image_proc import ROIExtractor
import photonpy.utils.multipart_tiff as tiff
import tifffile

import threading

def end_of_file(f):
    curpos = f.tell()
    f.seek(0,2)
    file_size = f.tell()
    f.seek(curpos,0)
    return curpos == file_size 


def detect_spots(sdcfg, calib, movie, sumframes, output_fn, batch_size, ctx:Context):
    sm = spotdetect.SpotDetectionMethods(ctx)

    with Context(ctx.smlm) as lq_ctx, open(output_fn, "wb") as f:
        roishape = [sdcfg.roisize,sdcfg.roisize]
        
        numframes = 0
        numrois = 0
        
        for i,img in enumerate(movie):
            if i==0:
                q,rq = sm.CreateQueue(img.shape, roishape, sdcfg, calib=calib,sumframes=sumframes, ctx=lq_ctx)
        
            def save_rois(rois_info, pixels):
                np.save(f, rois_info, allow_pickle=False)
                np.save(f, pixels, allow_pickle=False)
                nonlocal numrois
                numrois += len(rois_info)

            q.PushFrame(img)
            numframes += 1
            
            rl = rq.Length()
            if rl>batch_size:
                save_rois(*rq.Fetch())
                   
        while q.NumFinishedFrames() < numframes//sumframes:
            time.sleep(0.1)
        
        if rq.Length()>0:
            save_rois(*rq.Fetch())
            
        return numrois, numframes


def load_rois_iterator(rois_fn):
    """
    Load rois sequentially so we can deal with very large datasets
    """
    with open(rois_fn, "rb") as f:
        while not end_of_file(f):
            rois_info = np.load(f)
            pixels = np.load(f)
            yield rois_info, pixels
            
    
def load_rois(rois_fn):
    rois_info = []
    pixels = []
    for ri,px in load_rois_iterator(rois_fn):
        rois_info.append(ri)
        pixels.append(px)
    
    return np.concatenate(rois_info), np.concatenate(pixels)


def extract_rois_iterator(movie, roipos, roiframe, calib, roisize, 
                          ctx:Context, minBatchSize):
    """
    Extract predefined ROIs from a TIFF or other image iterator. 
    Calib: camera calibration as created with create_calib_obj
    roipos: Corner positions [[y,x]...]
    TODO: Save to disk in batches to remove memory bottleneck
    """
    roilist = np.zeros(len(roipos),dtype=ROIExtractor.ROIType)
    roilist['cornerpos'] = roipos
    roilist['startframe'] = roiframe
    roilist['numframes'] = 1

    with Context(ctx.smlm) as ex_ctx:
        q = None        
        numframes = 0
        for i,img in enumerate(movie):
            if i == 0:
                q = ROIExtractor(img.shape, roilist, 1, roisize, calib, ex_ctx)

            q.PushFrame(img)
            numframes += 1
 
            resultcount = q.GetResultCount()
            if resultcount > minBatchSize:
                rois,frames = q.GetResults(resultcount)
                yield rois,frames

        while not q.IsIdle():
            time.sleep(0.1)

            resultcount = q.GetResultCount()
            if resultcount > minBatchSize:
                rois,frames = q.GetResults(resultcount)
                yield rois,frames

        resultcount = q.GetResultCount()
        if resultcount>0:
            rois,frames = q.GetResults(resultcount)
            yield rois,frames


def localize_rois(rois_data_source, psf):
    """
    Runs PSF centroid estimation on the given ROIs using the PSF.
    The PSF must be created with cuda=True
    rois_data_source can either be a file generated by detect_rois, or 
    a tuple with the ROI data (rois_info, pixels)
    """
    
    if type(rois_data_source) == str:
        iterator = load_rois_iterator(rois_data_source)
    else:
        iterator = [rois_data_source]
    
    with EstimQueue(psf,batchSize=1024) as queue:
        count = 0
        for rois_info, pixels in iterator:
            roipos = np.zeros((len(rois_info),2))
            roipos[:,0] = rois_info['y']
            roipos[:,1] = rois_info['x']
            
            framenum = rois_info['id']
            queue.Schedule(pixels, ids=framenum, roipos=roipos)
            count += len(pixels)
            
        queue.WaitUntilDone()
        r = queue.GetResults()
        r.SortByID() # sort by frame numbers
        
        roisize = psf.sampleshape[-1]
        
        print(f"Filtering {len(r.estim)} spots...")
        minX = 2.1
        minY = 2.1
        r.FilterXY(minX,minY,roisize-minX-1, roisize-minY-1)
        
        r.estim[:,[0,1]] += r.roipos[:,[1,0]]

    return r

def create_calib_obj(gain,offset,imgshape,ctx):        
    if type(gain)==str:
        print(f'estimating gain from light {gain} and dark {offset} frames')
        light = tifffile.imread(gain)
        offset = tifffile.imread(offset)
        
        if not np.array_equal(imgshape, light.shape[1:]):
            raise ValueError(f'Camera light frames calibration data ({light.shape[1:]}) does not match with expected image size ({imgshape})')
            
        if not np.array_equal(imgshape, offset.shape[1:]):
            raise ValueError(f'Camera offset calibration ({offset.shape[1:]}) does not match with expected image size ({imgshape})')

        offset = np.mean(offset,0)
        sig = light-offset
        v = np.var(sig, 0)
        m = np.mean(sig,0)
        
        gain = v/m
        gain[gain==0] = np.mean(gain)
        print(f'mean camera gain: {np.mean(gain):.2f} ADU/photons offset: {np.mean(offset):.2f}',flush=True)
        

    if type(offset)==str:
        print(f'using mean values from {offset} as camera offset',flush=True)
        offset=tiff.get_tiff_mean(offset)

        if type(gain)!=str:
            gain = np.ones(imgshape)*gain
    
    if( type(offset)==np.ndarray):
        calib = GainOffsetImage_Calib(gain, offset, ctx)
    else:
        calib = GainOffset_Calib(gain, offset, ctx) 
    
    return calib




def localize(fn, cfg, output_file=None, progress_cb=None, estimate_sigma=False):
    """Perform localization on a tiff with a 2D Gaussian PSF model

    :param fn (str): .tif filename
    :param cfg: configuration dictionary for camera parameters and for
        PSF parameters.
    :param output_file: .hdf5 file where results will be saved.
    :param progress_cb: Progress callback
    :param estimate_sigma: if true, sigma will be estimated. In that case
        the sigma in cfg will be considered as initial estimate.

    :return: tuple with (EstimQueue_Result, image shape)
    """
    
    rois_output_fn = os.path.splitext(output_file)[0]+"-rois.npy"
    
    sigma = cfg['sigma']
    roisize = cfg['roisize']
    threshold = cfg['threshold']
    gain = cfg['gain']
    offset = cfg['offset']
    startframe = cfg['startframe'] if 'startframe' in cfg else 0
    maxframes = cfg['maxframes'] if 'maxframes' in cfg else -1
    sumframes = 1
    maxChiSquare = cfg['maxchisq'] if 'maxchisq' in cfg else None
    
    with Context() as ctx:
        imgshape = tiff.tiff_get_image_size(fn)
        
        print(imgshape)

        gaussian = Gaussian(ctx)
            
        spotDetector = spotdetect.SpotDetector(np.mean(sigma), roisize, threshold)

        if estimate_sigma:
            psf = gaussian.CreatePSF_XYIBgSigmaXY(roisize, sigma, True)
        else:
            psf = gaussian.CreatePSF_XYIBg(roisize, sigma, True)

        calib = create_calib_obj(gain,offset,imgshape,ctx)

        movie = tiff.tiff_read_file(fn, startframe, maxframes, progress_cb)
        numrois = detect_spots(spotDetector, calib, movie, sumframes, rois_output_fn, batch_size=20000, ctx=ctx)

        queue = EstimQueue(psf, batchSize=1024)

        scores=[]
        for  rois_info,pixels in load_rois_iterator(rois_output_fn):
            roipos = np.zeros((len(rois_info),2))
            roipos[:,0] = rois_info['y']
            roipos[:,1] = rois_info['x']
            scores.append(rois_info['score'])
            queue.Schedule(pixels, roipos=roipos, ids=rois_info['id'])
            
        scores=np.concatenate(scores)
        print(f'Median spot score: {np.median(scores)}')

        queue.WaitUntilDone()
        
        if progress_cb is not None:
            if not progress_cb(None,None): return None,None
        
        r = queue.GetResults()
        r.SortByID() # sort by frame numbers
        
        if maxChiSquare is not None:
            print(f"Filtering on chi-square at threshold {maxChiSquare}*{roisize*roisize}...")
            chiSqThreshold = maxChiSquare*roisize**2
            r.Filter(np.where(r.chisq<chiSqThreshold)[0])
            
        print(f"Filtering {len(r.estim)} spots at ROI boundary and iterations")
        minX = 2.1
        minY = 2.1
        r.FilterXY(minX,minY,roisize-minX-1, roisize-minY-1)
        r.Filter(np.where(r.iterations<50)[0])
        
        r.estim[:,[1,0]] += r.roipos
               
        nframes = np.max(r.ids)+1 if len(r.ids)>0 else 1
        print(f"Num spots: {len(r.estim)}. {len(r.estim) / nframes} spots/frame.")
        
        ds = Dataset.fromQueueResults(r, imgshape, config=cfg, imagefile=fn)
        if output_file is not None:
            ds.save(output_file)
        return ds
    

